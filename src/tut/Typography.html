<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html><head>

  <title></title>

</head><body>
  <div class="article">

    <p>In previous chapters we've seen how graphics primitives <a href="Graphics_State.html">inherit</a> the canvas's global state to determine their <a href="Color.html">color</a>, <a href="../ref/Line+Color.html#pen()">line-style</a>, and <a href="Geometry.html">position</a>. When dealing with text, the same settings apply but are joined by a number of additional attributes controlling the font to be used and the desired layout behavior. </p>


    <h1>Basic Typesetting</h1>
    <p>Unicode strings can be drawn to specific locations on the canvas with the <a href="../ref/Typography.html#text()">text()</a> command. They can either be drawn to a point or, if the optional <i>width</i> and <i>height</i> parameters are included, word-wrapped into a block of text.</p>

    <p>Text will be drawn in the current <a href="../ref/Line+Color.html#fill()">fill()</a> color and uses the canvas's current <a href="../ref/Typography.html#font()">font()</a> and <a href="../ref/Typography.html#layout()">layout()</a> state to style the string. Like all graphics primitives, its position and size are expressed in <a href="../ref/Canvas.html#size()">size()</a>-units and can be modulated by the current <a href="../ref/Transform.html#transform()">transform()</a>.</p>



    <h2>drawing text at a point</h2>
    <p>To draw some text to the canvas, simply pass a string followed by a pair of <code>x</code> &amp; <code>y</code> coordinates defining its "origin". Note that the origin point corresponds to the <em>baseline</em> of the text (rather than its upper-left corner). The text will be drawn as a single line unless you include manual line breaks in the string.</p>


    <p>To draw text in typefaces other than the default, call the <i>font()</i> command before placing your <i>text()</i> on the canvas. In its simplest usage, you can select a font by passing the name of a font <i>family</i>, the name of a <i>weight</i>, and/or the font's point <i>size:</i></p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basics.png"/></span>
      <pre>
x, y = 24, 56
arc(x,y, 6, fill='red') # the baseline ‘origin’ pt

font('Avenir', 'black', 32)
text('München', x, y)
</pre>
    </div>

    <p>If you want to italicize the text (or use the "oblique" variant of a typeface), set the <code>italic</code> keyword argument to a boolean:</p>
    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basic-lines.png"/></span>
      <pre>
x, y = 24, 24
font('Baskerville', 24, italic=True)
text('One.\nTwo.\nThree.', x, y)
</pre>
      </div>


    <h2>drawing a block of text</h2>
    <p>The <i>text()</i> command allows you to typeset columns of text with automatic word-wrapping and optional hyphenation. To enable this behavior, simply pass a numerical <i>width</i> argument after the initial <code>x</code> and <code>y</code> parameters to set the maximium line-length before the text system will break the line.</p>

    <p>Note that the <code>x</code>/<code>y</code> location still corresponds to the <em>baseline</em> of the first character and that the rendered text will be as tall as necessary to contain the entire string being drawn. For instance, typesetting a paragraph with a maximum width of 270 would look something like:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basic-block.png"/></span>
      <pre>
lorem = "Early in the bright sun-yellowed morning, Stuart McConchie swept the sidewalk before Modem TV Sales & Service, hearing the cars along Shattuck Avenue and the secretaries hurrying on high heels to their offices, all the stirrings and fine smells of a new week, a new time in which a good salesman could accomplish things."
x, y = 12, 24

font("american typewriter", 16)
layout(leading=1.3)
text(lorem, x, y, 270)
</pre>
    </div>

    <p>If your string is long enough, it's quite possible that your text will spill off the bottom of the canvas. To constrain the total number of lines drawn you can include a fourth numerical parameter: <i>height</i>. When both a maximal <i>width</i> and <i>height</i> are defined, the string will be word-wrapped up to the point where the next text line would cause the Text to "overflow" its maximum height.</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basic-block-height.png"/></span>
      <pre>
lorem = "It was about eleven o'clock in the morning, mid October, with the sun not shining and a look of hard wet rain in the clearness of the foothills."
font('baskerville', 16)

# left: fixed width, unlimited height
text(lorem, 10,20, 120)

# right: clip to fixed width and height
text(lorem, 150,20, 120,60)
</pre>
    </div>

    <p>The characters in the string that don't fit within the maximum <i>width</i> and <i>height</i> aren't "lost" however. As we'll see below you can "<a href="../ref/Typography.html#Text.flow()">flow</a>" text across multiple columns or even pages (consult the <a href="#advanced-layout">Advanced Layout</a> section for details).</p>


    <h2>optional text arguments</h2>

    <p>When you draw a piece of text it "inherits" the current paragraph- and character-style, but you can selectively override these settings by passing keyword arguments to the <i>text()</i> command. You can call <i>text()</i> with any of the keyword arguments supported by the <i>font()</i> and <i>layout()</i> commands. Your alterations will apply only to that <i>Text</i> object and won't affect the global state:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basic-overrides.png"/></span>
      <pre>
fill(0.3)
font('avenir next', 'medium', 32)

text('Good', 100,40)
text('big', 10,120, weight='bold', size=120, sc=True)
text('or Red', 16,155, fill='red')</pre>
    </div>

    <p>When you pass a string to the <i>text()</i> command, you can either include it as the first positional argument or as a keyword argument called <code>str</code>. When using the keyword argument, the positional arguments are dedictated to setting the text's location and size (<i>x</i>, <i>y</i>, <i>width</i>, and <i>height</i>).</p>

    <p>This can help keep your code readable when drawing long strings that would otherwise push the coordinates off the right margin of the editor. For instance the following usages are equivalent:</p>
    <pre>
text("Something very long that ends up hiding the coordinates (or at least making them painful to jump to when editing)", 100,100, 256,256, italic=True)
text(100,100, 256,256, italic=True, str="Something very long that no longer hides the coordinates (since now just the string itself is spilling off the screen)")
</pre>


    <h2>text alignment</h2>

    <p>By default, PlotDevice renders text with a left-alignment (a.k.a. "rag right"). You can change this setting by passing an <code>align</code> keyword argument to the <i>layout()</i> command to update the "current" canvas state. It can also be passed to the <i>text()</i> command itself (to set the alignment for just that invocation).</p>

    <p>The current alignment setting applies both when drawing to a point or into a block of text. However, the alignment's effect on positioning is quite different depending on whether or not a <i>width</i> was defined for the given <i>Text</i> object. When drawing to a point, the text will "grow" out from the origin based on the alignment setting:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-align-point.png"/></span>
      <pre>
x = WIDTH/2

text("left",   x, 50)
text("center", x, 100, align=CENTER)
text("right",  x, 150, align=RIGHT)

with stroke(.7), pen(dash=3):
  line(x,0, x,HEIGHT)
</pre>
      </div>

  <p>When drawing a block of text, the alignment will be interpreted based on the left &amp; right edges defined by the <i>x</i> and <i>width</i> arguments:</p>
  <div class="example">
    <span><img class="border" src="../etc/tut/typography-align-block.png"/></span>
    <pre>
x, w = 30, 140

text("left",   x,50,  w)
text("center", x,100, w, align=CENTER)
text("right",  x,150, w, align=RIGHT)

with stroke(.7), pen(dash=3):
    line(x,0, dy=HEIGHT)
    line(x+w,0, dy=HEIGHT)</pre>
  </div>



    <h1>Setting the Style</h1>


    <p>The <i>text()</i> command simply draws a string to the screen with the specified location and size. The rendered text's typeface, spacing, and other typographical details are specified by calling the <i>font()</i> and <i>layout()</i> commands (which roughly correspond to the <span class="message">Character</span> and <span class="message">Paragraph</span> palettes found in the Adobe apps).</p>

    <h2>Character Styles</h2>

    <p>The <i>font()</i> command takes up to three positional arguments, allowing you to set the typeface's <i>family</i>, <i>weight</i>, and point <i>size</i>. All the arguments are optional since any omitted parameters will default to the canvas's "current" font-state.
</p>

    <p>Each time you call <i>font()</i>, the canvas's state is updated and an inspectable <a href="../ref/Typography.html#Font">Font</a> object is returned reflecting the new values:</p>
    <pre>
print(font())                  # Font(Helvetica Neue 24pt | Regular)
print(font('Avenir', 'heavy')) # Font(Avenir 24pt | Heavy)
print(font(128))               # Font(Avenir 128pt | Heavy)
print(font('Baskerville', 64)) # Font(Baskerville 64pt | Bold)
print(font('light'))           # Font(Baskerville 64pt | Regular)
</pre>

    <p>In addition to the positional parameters, <i>font()</i> also accepts a variety of keyword arguments for selecting a typeface, toggling OpenType features, and even tweaking the kerning between neighboring glyphs:</p>


    <ul>
      <li>Typeface selection: <a href="../ref/Typography.html#font(family)">family</a>, <a href="../ref/Typography.html#font(weight)">weight</a>, <a href="../ref/Typography.html#font(width)">width</a>, <a href="../ref/Typography.html#font(variant)">variant</a>, <a href="../ref/Typography.html#font(italic)">italic</a></li>
      <li>OpenType Features: <a href="../ref/Typography.html#font(sc)">sc</a>, <a href="../ref/Typography.html#font(ss)">ss</a>, <a href="../ref/Typography.html#font(lig)">lig</a>, <a href="../ref/Typography.html#font(osf)">osf</a>, <a href="../ref/Typography.html#font(tab)">tab</a>, <a href="../ref/Typography.html#font(vpos)">vpos</a>, <a href="../ref/Typography.html#font(frac)">frac</a></li>
      <li>Font Metrics: <a href="../ref/Typography.html#font(size)">size</a>, <a href="../ref/Typography.html#font(tracking)">tracking</a></li>
    </ul>

    <p>The <i>font()</i> command works <b>incrementally</b> and can change as many (or as few) parameters as desired on each invocation. Note how the typeface and size can be set once at the beginning of the script with subsequent calls tweaking the style:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-styles-font.png"/></span>
      <pre>
font('jenson', 'medium', 22)
text("September 1972", 20,40)

font(osf=True) # old-style figures
text("September 1972", 20,90)

font(sc=True) # small-caps
text("September 1972", 20,140)

font(sc=all, tracking=50) # letter-spacing
text("September 1972", 20,190)
</pre>
    </div>


    <h2>Paragraph Styles</h2>

    <p>The <i>layout()</i> command accepts any number of keyword arguments affecting line-wrapping behavior, spacing, and alignment on a paragraph-by-paragraph level (as separated by <code class="str">"\n"</code> characters in the <i>text()</i> string):</p>

    <ul>
      <li>Line layout: <a href="../ref/Typography.html#layout(align)">align</a>, <a href="../ref/Typography.html#layout(hyphenate)">hyphenate</a></li>
      <li>Horizontal spacing: <a href="../ref/Typography.html#layout(indent)">indent</a>, <a href="../ref/Typography.html#layout(margin)">margin</a></li>
      <li>Vertical spacing: <a href="../ref/Typography.html#layout(leading)">leading</a>, <a href="../ref/Typography.html#layout(spacing)">spacing</a></li>
    </ul>

    <p>The most common uses of <i>layout()</i> are setting the text alignment (to <code class='kw'>LEFT</code>, <code class='kw'>RIGHT</code>, <code class='kw'>CENTER</code>, or <code class='kw'>JUSTIFY</code>) and controlling the inter-line spacing (measured as a multiple of the current font size):</p>
    <div class="example">
      <span><img class="border" src="../etc/tut/typography-styles-layout.png"/></span>
      <pre>
lorem = "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."

font('Georgia', 14)
text(lorem, 10,20, 80)

layout(align=RIGHT, leading=1.6)
text(lorem, 110,20, 80)
</pre>
    </div>


    <h2>The Global Stylesheet</h2>

    <p>If you find yourself issuing the same <i>font()</i> and <i>layout()</i> commands repeatedly in a script, you can simplify your code by storing your settings in the canvas's global <a href="../ref/Typography.html#stylesheet()">stylesheet()</a> then referring to them by name.</p>

    <p>To create a style, call <i>stylesheet()</i> with a name as its first argument followed by any combination of the keyword arguments supported by <i>font()</i> and <i>layout()</i>. You can then refer to the style's name in subsequent calls to <i>text()</i> without affecting the canvas's current type style:</p>
    <div class="example">
      <span><img class="border" src="../etc/tut/typography-styles-named.png"/></span>
      <pre>
stylesheet('emph', italic=True)
stylesheet('bright', weight='heavy', fill='red')

font('Avenir Next', 20)
text('handgloves', 10,40)
text('handgloves', 10,70, style='emph')
text('handgloves', 10,100, style='bright')

font('Joanna MT', 28)
text('handgloves', 10,150)
text('handgloves', 10,180, style='emph')
text('handgloves', 10,210, style='bright')
</pre>
    </div>



    <h1>Building Text Up</h1>

    <p>The <i>text()</i> command typically functions in a fire-and-forget manner – styling and drawing your prepared string in a single step. However, it's quite common to need lower-level control over substrings within your run of text. For these more complex use-cases, PlotDevice provides a number of convenience methods for assembling text iteratively and decomposing marked-up strings.</p>


    <h2>incremental text</h2>

    <p>Each call to the <i>text()</i> command returns a <a href="../ref/Typography.html#Text">Text</a> object and adds it to the canvas. If you save a reference to this object in a variable, you can use its <a href="../ref/Typography.html#Text.append()">append()</a> method to add more text to the end of the string (potentially with a different character style).</p>

    <p>The <i>append()</i> method takes a single positional argument (a string) which will be added to the end of the <i>Text</i> run using the character &amp; paragraph style that the <i>Text</i> object was created with. You can also pass any of the styling keyword arguments supported by the <i>text()</i> command to customize the style of your appended substring.</p>

    <p>This allow you to build up a run of text incrementally, which can be handy when typesetting items pulled from a list or dictionary. For instance, here we create an "empty" text object then iterate over a list of color names. Each name is appended to the <i>Text</i> and sets its fill color using the same value.</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-basic-append.png"/></span>
      <pre>
names = ['red', 'tan', 'aqua', 'blue', 'cyan', 'gold', 'gray', 'lime', 'peru', 'pink', 'plum', 'snow', 'teal', 'azure', 'beige', 'brown', 'coral', 'green', 'ivory', 'khaki', 'linen', 'olive', 'deepskyblue', ]
background(.15)
font('gill sans')

t = text('', 10,26, 280, fill=.5)
for name in names:
    t.append(name, fill=name)
    t.append(' / ', weight='light')
</pre>
    </div>


    <h2>inline styles</h2>
    <p>When you pass a string to <i>text()</i>, the entire run will be typeset with the same styling characteristics. If you need finer granularity, you can use XML-like tags to mark-up the string. Tag names will be matched against the <i>stylesheet()</i> and any elements with the same name as a defined style will use those settings.</p>

    <p>To enable this behavior, simply pass your string as the <code>xml</code> keyword argument when calling <i>text()</i>. Note that "nested" tags will cascade their styles in a manner similar to CSS selectors. For instance, here the word "battery" inherits both the "bold" style and its enclosing "caps" style:</i></p>
    <div class="example">
      <span><img class="border" src="../etc/tut/typography-styles-inline.png"/></span>
      <pre>
stylesheet('caps', sc=True, tracking=40)
stylesheet('bold', weight='bold')

font('avenir next', 19)
text(12,42, xml='correct &lt;caps&gt;horse &lt;bold&gt;battery&lt;/bold&gt; staple&lt;/caps&gt;')
</pre>
    </div>
    <p>You can also use tags that do <b>not</b> have a corresponding definition in the <i>stylesheet()</i>. They will not be typeset any differently from the enclosing text, but may still be useful since they can be accessed using the <i>Text</i> object's <a href="../ref/Typography.html#Text.select()">select()</a> method. In addition to providing layout-geometry information, the <a href="../ref/Typography.html#TextFragment">TextFragment</a> objects returned by <i>select()</i> also provide access to any <a href="http://www.xmlfiles.com/xml/xml_attributes.asp">attributes</a> defined in the start-tag.</p>

    <h2>text metrics</h2>

    <p>Since you may be interested in positioning multiple <i>Text</i> objects relative to one another, it's often handy to know how much space a given run of text will require <i>before</i> drawing it. For this you can use the <a href="../ref/Misc.html#measure()">measure()</a> command, passing a string along with an optional maximum width and height.</p>

    <pre>print(measure('lorem ipsum dolor')) # all on one line
>>> Size(193.848, 28.8)
print(measure('lorem ipsum dolor', 100, 999)) # word-wrapped at 100px
>>> Size(72.048, 86.4)
</pre>

    <p>You can unpack the returned <a href="../ref/Misc.html#Size">Size</a> object into a pair of floating point values using <a href="http://robert-lujo.com/post/40871820711/python-destructuring">destructuring assignment</a>, or take advantage of the <i>textwidth()</i> and <i>textheight()</i> utility functions to access just a single dimension of the measurement. For instance, the following are equivalent:</p>
    <pre>w, h = measure('foo bar baz')</pre>
    <pre>w = textwidth('foo bar baz')
h = textheight('foo bar baz')</pre>

    <p>Note that the various metrics commands will perform a full typesetting run with the provided string using the current <i>font()</i> and <i>layout()</i> setting but will <b>not</b> add it to the canvas. Since typesetting is a fairly expensive operation, you'll see performance improvements if you cache these results rather than repeatedly measuring the same strings in your scripts.</p>

    <h2>external sources</h2>

    <p>When typesetting long runs of text, you may find it more convenient to load your strings from external files rather than defining them within your script. You can do this manually by using the <a href="../ref/Misc.html#read()">read()</a> command to load a file then passing its resturn value to <i>text()</i>. As a bit of syntactic sugar around this pattern, you can also pass a file-path or URL to the <i>text()</i> command directly through its <code>src</code> keyword argument. For example, both the following are equivalent:</p>

<pre>content = read('http://plotdevice.io/data/lorem.txt')
text(40,40, str=content)
</pre>
<pre>text(40,40, src='http://plotdevice.io/data/lorem.txt')</pre>

    <p>In addition to loading plain text files, the <code>src</code> parameter also provides special handling for RTF, HTML, and XML files (primarily differentiated by their file extension). XML files will be interpreted in the manner described by the Inline Styles section above.</p>

    <p>HTML and RTF files will preserve their formatting regardless of the current <i>font()</i> and <i>layout()</i> state (though they will honor any <i>width</i> and <i>height</i> parameters present in the <i>text()</i> call). Note that external stylesheets will <i>not</i> be fetched when loading an HTML file, but inline <code>&lt;style&gt;</code> tags can still be used.</p>


    <h1>Breaking Text Down</h1>

    <p>The layout performed by the <i>text()</i> command may be automatic, but it's far from a black-box. The <i>Text</i> object it returns can be queried for a wide variety of layout- and character-level information about the string being typeset.</p>

    <h2>layout geometry</h2>
    <p>When you create a <i>Text</i> object with a fixed width and height, its actual size on the canvas is determined by how much of the string fits within that area. You can access both the maximal size and the portion that was required for typestting through the <i>Text</i> object's <i>frame</i> and <i>bounds</i> properties respectively.</p>

    <p>Both of these properties return a <a href="../ref/Misc.html#Region">Region</a> object specifying the origin and size of the rectangle being measured. You can access a <i>Region</i>'s <i>x</i>, <i>y</i>, <i>w</i>, and <i>h</i> properties to perform additional layout calculations or pass it to one of the primitive drawing commands directly:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-bounds.png"/></span>
      <pre>
karlton = "There are only two hard things in Computer Science: cache invalidation and naming things."

font('american typewriter', 20)
t = text(20, 40, 200, 150, str=karlton)

nofill()
rect(t.frame, stroke=.6)
rect(t.bounds, stroke='red', dash=4)
</pre>
    </div>

    <p>In addition to block-level metrics, the <i>Text</i> object also allows you to access the dimensions of individual lines. The <i>lines</i> property is a list of <a href="../ref/Typography.html#TextFragment">TextFragment</a> objects which provide the same pair of <i>frame</i> and <i>bounds</i> regions as seen above. </p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-lines.png"/></span>
      <pre>
jabber = "Twas brillig, and the slithy toves did gyre and gimble in the wabe: all mimsy were the borogoves, and the mome raths outgrabe."

font('american typewriter', 20)
t = text(20,40, 250,160, str=jabber)
print(len(t.lines))
>>> 6

nofill()
slug = t.lines[2] # metrics of line 3
rect(slug.frame, stroke=0.7)
rect(slug.bounds, stroke='red', dash=4)
</pre>
    </div>

    <h2>finding substrings</h2>

    <p>In addition to inspecting the <i>Text</i> in terms of its block- or line-level layout, you can also access sub-regions of it based on its content. Using index notation, you can retrieve a <a href="../ref/Typography.html#TextFragment">TextFragment</a> object describing a single glyph or a "slice" of them. </p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-fragments.png"/></span>
      <pre>
font('Joanna MT', 80, italic=True)
t = text(20,120, str='Axiomatic')

first = t[0]
middle = t[3:6]
last = t[-1]

nofill()
rect(first.bounds, stroke='red')
rect(middle.bounds, stroke='orange')
rect(last.bounds, stroke='green')</pre>
    </div>

    <p>You can iterate over the characters in a <i>Text</i> object using a for loop. With each pass through the loop, a new single-character <i>TextFragment</i> is returned. Note that the fragment's geometry (drawn below in grey) reflects the font's line-height rather than the shape of the individual letterform. The bounds of the glyph itself can be found by examining the <i>TextFragment</i>'s <a href="../ref/Drawing.html#Bezier">Bezier</a> representation using the <i>path</i> attribute (drawn below in red):</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-glyphs.png"/></span>
      <pre>
font('Helvetica Neue', 64)
t = text(20, 72, str="Spokane")

nofill()
for glyph in t:
    rect(glyph.bounds, stroke=.9)

for glyph in t:
    rect(glyph.path.bounds, stroke='red')
</pre>
    </div>



    <p><i>Text</i> objects also have a basic understanding of sentence structure. The <i>words</i> and <i>paragraphs</i> properties return lists of <i>TextFragment</i> objects separated by whitespace (or punctuation) and line-breaks respectively:</p>
    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-words.png"/></span>
      <pre>
rhyme = "Tinker, tailor, soldier, sailor, rich man, poor man, begger man, thief"

font('Joanna MT', 32, italic=True)
t = text(20,40, 270,160, str=rhyme)

nofill()
for word in t.words:
    rect(word.bounds, stroke=.4, dash=2)</pre>
    </div>

    <p>You can search within a <i>Text</i> object using <a href="https://docs.python.org/2/howto/regex.html">regular expressions</a> (or simple strings). The <a href="../ref/Typography.html#Text.find()">find()</a> method returns a <i>TextFragment</i> for every matching substring within the <i>Text</i>:</p>


    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-find.png"/></span>
      <pre>
font('Palatino', 23)
t = text(20, 40, 250, str="The frog in the fog bares its fangs in good humor")

for match in t.find('good'): # simple
    rect(match.bounds, stroke='steelblue', fill=None)

for match in t.find(r'f\w+'): # regex
    rect(match.bounds, stroke='firebrick', fill=None)
</pre>
    </div>


    <p>We've already seen how tags within an XML-formatted <i>Text</i> object can be used with the <a href="../ref/Typography.html#stylesheet()">stylesheet()</a> command to specifiy typographic details. Additionally, tags can be used to locate particular regions of the text after it has been typeset. Calling the <i>Text</i> object's <a href="../ref/Typography.html#Text.select()">select()</a> method with a tag name will return a <i>TextFragment</i> for each element with that name &ndash; even when no style has been assigned to it:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-select.png"/></span>
      <pre>
haystack = """...................
.........&lt;needle&gt;.&lt;/needle&gt;.........
..................."""

font('Helvetica Neue', 32)
t = text(60,32, xml=haystack)
for match in t.select('needle'):
    rect(match.bounds, stroke='red', fill=None)
</pre>
    </div>

    <p>Tags in an XML string can also be defined with associated "attributes" of the form:</p>
    <pre>&lt;tag name="value"&gt;…&lt;/tag&gt;</pre>

    <p>These attributes can be accessed by <i>select()</i>-ing the tag by name and accessing the resulting <i>TextFragment</i>'s <i>attrs</i> property. For example, by adding a <code>note</code> attribute to the <code>fn</code> tag, footnotes can appear alongside their referents in the main text:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-layout-select2.png"/></span>
      <pre>
flaubert = """“Five hundred lines for all the class!” shouted in a furious voice stopped, like the Quos ego&lt;fn note="A quotation from the Aeneid signifying a threat."&gt;1&lt;/fn&gt;, a fresh outburst. “Silence!” continued the master indignantly, wiping his brow with his handkerchief, which he had just taken from his cap. “As to you, ‘new boy,’ you will conjugate ‘ridiculus sum’&lt;fn note="I am ridiculous."&gt;2&lt;/fn&gt; twenty times.”
Then, in a gentler tone, “Come, you’ll find your cap again; it hasn’t been stolen.”"""

font('Adobe Jenson', 14)
layout(hyphenate=True, indent=True)
stylesheet('fn', vpos=1, fill='red')

body = text(10,20, 170, xml=flaubert)
for fn in body.select('fn'):
    note = text('', 190, fn.baseline.y, width=100, italic=True)
    note.append(fn.text, vpos=1)
    note.append(' '+fn.attrs['note'])
</pre>
    </div>

    <a name="advanced-layout"></a>
    <h1>Advanced Layout</h1>

    <p>Sometimes you want to do more than draw a single line or column of text. Luckily, PlotDevice provides extensive control over line-layout within a text block, the ability to "flow" text between columns, and even the ability to generate multi-page booklets. In this section we'll look at some of the <i>Text</i> object's more sophisticated options. </p>


    <h2>Whitespace and Indentation</h2>
    <p>Beyond setting the location and dimensions of a <i>Text</i> object's frame, you can control a number of typographic paramters at the line- and paragraph-level by using the <i>layout()</i> command (or by defining <code>indent</code>, <code>spacing</code>, or <code>margin</code> values within a stylesheet):</p>
    <div class="media" style="margin:0;">
      <img class="border" src="../etc/tut/typography-advanced-layout.png">
    </div>



    <p>During typesetting, PlotDevice will try to fill the full horizontal width of a <i>Text</i> object's frame before breaking to a new line. If you'd like to add some additional "gutter" space on the right or left edge of the defined width, you can do so using the <i>layout()</i> command's <code>margin</code> argument. The margin can be defined using a single value (in canvas units) to specify the left gutter, or a tuple of two values defining the left and right gutters respectively:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-margin.png"></span>
      <pre>
dickens = "London. Michaelmas term lately over, and the Lord Chancellor sitting in Lincoln's Inn Hall. Implacable November weather. As much mud in the streets as if the waters had but newly retired from the face of the earth, and it would not be wonderful to meet a Megalosaurus, forty feet long or so, waddling like an elephantine lizard up Holborn Hill. Smoke lowering down from chimney-pots, making a soft black drizzle, with flakes of soot in it as big as full-grown snowflakes—gone into mourning, one might imagine, for the death of the sun. Dogs, undistinguishable in mire. Horses, scarcely better; splashed to their very blinkers. Foot passengers, jostling one another's umbrellas in a general infection of ill temper, and losing their foot-hold at street-corners, where tens of thousands of other foot passengers have been slipping and sliding since the day broke (if this day ever broke), adding new deposits to the crust upon crust of mud, sticking at those points tenaciously to the pavement, and accumulating at compound interest."

font('Baskerville', 13)
x, y = 0, 20
w, h = 300, 90

layout(margin=0) # the default
text(x,y, w,h, str=dickens)
y += 100

layout(margin=40) # left-side margin
text(x,y, w,h, str=dickens)
y+=100

layout(margin=(80,40)) # both-sides margin
text(x,y, w,h, str=dickens)</pre>
    </div>

    <p>When preparing long passages for typesetting, you should be sure to use only a <em>single</em> carriage-return to separate paragraphs. You can then control the inter-paragraph spacing using the <i>layout()</i> command's <code>spacing</code> argument. It accepts numeric values expressed in terms of the current font’s line-height (with a default of 0).</p>

    <p>The <code>spacing</code> parameter can be either a single numeric value (specifying the extra space to add <em>before</em> the paragraph), or a tuple of two values (defining the extra before- and after-space respectively).</p>

<div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-spacing.png"></span>
      <pre>
txt = """Paragraph one has five words.
Paragraph two is shorter.
Paragraph three is followed by a snowman.
☃ """
font(13)

layout(spacing=0) # the default
text(20,30, 100, str=txt)

layout(spacing=1) # add 1 lineheight of extra space
text(150,30, 120, str=txt)
</pre>
    </div>


    <p>The <i>layout()</i> command's optional <code>indent</code> argument allows you to specify the amount of extra space that will be added to the opening line of a paragraph. It accepts numeric values expressed in terms of the current font's <a href="https://en.wikipedia.org/wiki/Em_(typography)">em</a> size (with a default of 0).</p>
    <p>PlotDevice's indentation logic follows guidelines from book typography. In particular:</p>
    <ol>
      <li>The first paragraph in a <i>Text</i> is <b>never</b> indented</li>
      <li>Paragraphs preceded by a single carriage-return <b>are</b> indented</li>
      <li>Paragraphs preceded by a blank line are <b>not</b> indented</li>
    </ol>


    <p>For example, consider this case where we set the indentation size to 1.4 em's and render a multi-line string:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-indent.png"></span>
      <pre>
txt="""The first paragraph extends to the first carriage return character and will never be indented by default.
The second paragraph follows the first and will be indented according to the current layout settings.
The third paragraph is just like the second. It is also indented.

A final paragraph, preceded by a blank line, represents the beginning of a new ‘section’ and suppresses any indentation.
"""

layout(indent=1.4)
font('Georgia', 16)
text(30,40, width=250, str=txt)
</pre>
    </div>

    <p class="double-dagger">The indentation defaults can be overridden on a paragraph-by-paragraph basis through the use of "escape codes". When calling text() with a <code>str</code> argument, lines beginning with <code class="str">"\t"</code> will be indented and those beginning with <code class="str">"\b"</code> will have their indentation suppressed. For <code>xml</code> arguments, you should use the entities <code class="str">"&amp;indent;"</code> and <code class="str">"&amp;flush;"</code> instead.</p>

    <p>A less-common (but still useful) case is the use of negative indentation values. These can come in handy when typesetting definition-style lists, poetry, and the like. With negative indentation, the previous logic is disregarded and every paragraph is "outdented" identically regardless of its context:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-outdent.png"></span>
      <pre>
txt="""The first paragraph extends to the first carriage return character and will be outdented by the negative indentation value.
The second paragraph follows the first and will be outdented too.
The third paragraph is outdented just like the prior two.

A final paragraph, preceded by a blank line, represents the beginning of a new ‘section’ but is outdented all the same.
"""

layout(indent=-1.4)
font('Georgia', 16)
text(30,40, width=250, str=txt)
</pre>
    </div>


    <h2>Multi-column Text</h2>

    <p>When you provide both a <i>width</i> and a <i>height</i> argument to the <i>text()</i> command, PlotDevice will draw only the portions of the string that fit within the rectangle they define. If your string is long enough, it's quite possible for a portion of it to "overflow" these maximum dimensions and not be visible on the canvas.</p>

    <p>To continue drawing the characters that didn't fit in the initial block of text, you must provide a new rectangle for the rest of the string to "flow" into. Depending on the length of your string and the size of the text-blocks you're filling, there's no telling how many of these "columns" you'll need to create altogether.</p>

    <p>By looping over the <i>Text</i> object's <a href="../ref/Typography.html#Text.flow()">flow()</a> method, you can define a layout for multiple columns of text iteratively. This saves you from having to pre-calculate the total text size and allows you to express the layout of each column <i>relative</i> to the previous one.</p>

    <p>When calling <i>flow()</i> you can provide an optional argument for the maximum number of columns you wish to lay out. It will return a series of <a href="../ref/Typography.html#TextBlock">TextBlock</a> objects with <i>x</i>, <i>y</i>, <i>width</i>, and <i>height</i> properties that are equal to those of the <b>previous</b> <i>TextBlock</i> in the sequence. Within the loop you can simply increment or decrement these positional values to create regularly spaced columns:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-flow.png"/></span>
      <pre>
kafka = 'Someone must have been telling lies about Josef K., he knew he had done nothing wrong but, one morning, he was arrested. Every day at eight in the morning he was brought his breakfast by Mrs. Grubach’s cook. Mrs. Gru-bach was his landlady but today she didn’t come. That had never happened before. K. waited a little while, looked from his pillow at the old woman who lived opposite and who was watching him with an inquisitiveness quite unusual for her, and finally, both hungry and disconcerted, rang the bell. There was immediately a knock at the door and a man entered.'

font('Adobe Garamond', size=10)
layout(align=JUSTIFY, hyphenate=True)
t = text(20,20, 120,120, str=kafka)
for block in t.flow(2):
    block.x += block.width + 20
</pre>
    </div>

    <p>The <i>TextBlock</i>s defined during a <i>flow()</i> loop have an additional attribute called <i>idx</i> which marks their sequence in the flow (starting from zero). You can use this value within the loop to influence your layout logic. As your layouts get more complex, you may also find it helpful to place the logic within a function rather than defining it within the for loop – this keeps your code cleaner and also allows you to re-use the same layout scheme on multiple <i>Text</i> objects.</p>

    <p>To have a function you've defined control the layout, pass it to the <i>flow()</i> method as an argument along with the maximum number of columns you wish to produce. If you'd prefer for the flow process to continue until all the text has been laid out, use the <code class="kw">all</code> keyword rather than an integer for the max count:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-flow2.png"/></span>
      <pre>
kafka = 'and a man entered. He had never seen the man in this house before. He was slim but firmly built, his clothes were black and close-fitting, with many folds and pockets, buckles and buttons and a belt, all of which gave the impression of being very practical but without making it very clear what they were actually for. “Who are you?” asked K., sitting half upright in his bed. The man, however, ignored the question as if his arrival simply had to be accepted, and merely replied, “You rang?” “Anna should have brought me my breakfast,” said K. He tried to work out who the man actually was, first in silence, just through observation and by thinking about it, but the man didn’t stay still to be looked at for very long. Instead he went over to the door, opened it slightly, and said to someone who was clearly standing immediately behind it, “He wants Anna to bring him his breakfast.” There was a little laughter in the neighbouring room, it was not clear from the sound of it whether there were several people laughing. The strange man could not have learned anything from it that he hadn’t known already, but now he said to K., as if making his report “It is not possible.” “It would be the first time that’s happened,” said K., as he jumped out of bed and quickly pulled on his trousers. “I want to see who that is in the next room, and why it is that Mrs. Grubach has let me be disturbed in this way.” It immediately occurred to him that he needn’t have said this out loud, and that he must to some extent have acknowledged their authority by doing so, but that ...'

font('Adobe Garamond', size=10)
layout(align=JUSTIFY, hyphenate=True)

def leftright(block):
    if block.idx % 2:
        block.x += block.width + 20
    else:
        block.x = 0
        block.y += block.height + 20

t = text(20,24, 120,120, str=kafka)
t.flow(all, leftright)
</pre>
    </div>

    <p>The <i>TextBlocks</i> that you add during a <i>flow()</i> become "children" of the original <i>Text</i> object and can be accessed through its <i>blocks</i> property as a list. The parent <i>Text</i> and all of its child "blocks" will be laid out as a group, sharing the same root position, style, and <a href="Geometry.html">transformation</a> state. To get a sense of how the parent object encapsulates its children, notice how the <i>bounds</i> or the <i>Text</i> (drawn in grey) contains all the <i>bounds</i> boxes of the <i>TextBlock</i>s within it:</p>

    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-flow3.png"/></span>
      <pre>
welles = 'Before the law, there stands a guard. A man comes from the country, begging admittance to the law. But the guard cannot admit him. May he hope to enter at a later time? That is possible, said the guard. The man tries to peer through the entrance. He’d been taught that the law was to be accessible to every man. “Do not attempt to enter without my permission”, says the guard. I am very powerful. Yet I am the least of all the guards. From hall to hall, door after door, each guard is more powerful than the last. By the guard’s permission, the man sits by the side of the door, and there he waits. For years, he waits. Everything he has, he gives away in the hope of bribing the guard, who never fails to say to him “I take what you give me only so that you will not feel that you left something undone.” Keeping his watch during the long years, the man has come to know even the fleas on the guard’s fur collar. Growing childish in old age, he begs the fleas to persuade the guard to change his mind and allow him to enter. His sight has dimmed, but in the darkness he perceives a radiance streaming immortally from the door of the law. And now, before he dies, all he’s experienced condenses into one question, a question he’s never asked. He beckons the guard. Says the guard, “You are insatiable! What is it now?” Says the man, “Every man strives to attain the law. How is it then that in all these years, no one else has ever come here, seeking admittance?” His hearing has failed, so the guard yells into his ear. “Nobody else but you could ever have obtained admittance. No one else could enter this door! This door was intended only for you! And now, I’m going to close it.” This tale is told during the story called “The Trial”. It’s been said that the logic of this story is the logic of a dream... a nightmare.'

font('Adobe Garamond', size=10)
t = text(20,26, 80,120, str=welles)
for block in t.flow(3):
    block.x += block.width + 10
    block.y += 40

nofill()
rect(t.bounds, stroke=.6)
for block in t.blocks:
    rect(block.bounds, stroke='red', dash=4)
</pre>
    </div>


    <p>Ordinarily, the <i>flow()</i> method will only create a new <i>TextBlock</i> when it has completely filled the prior block. However you can force a "page break" of sorts by including a form-feed character <code class="str">"\f"</code> in your string (or a <code class="str">"&amp;break;"</code> entity when using XML). Here, we're reusing the grid-layout from above but skipping from field to field rather than waiting for an entire frame to overflow before creating a new block:</p>


    <div class="example">
      <span><img class="border" src="../etc/tut/typography-advanced-flow4.png"/></span>
      <pre>
fake_id = """NAME\fJean d’Eau\fEYES\fViolet\fHEIGHT\f3'5"\fAGE\f137\fADDRESS\f123 Fake St.\nSpringfield, IL 62705"""

font('Avenir', size=14)
t = text(20,26, str=fake_id)
for block in t.flow():
    if block.idx % 2:
        block.x += 100
    else:
        block.x = 0
        block.y += 30
</pre>
    </div>



    <h2>Pagination</h2>

    <p>The <i>Text</i> object's <i>flow()</i> method is great for laying out columns of text parallel to one another, but what if you want to deal with these blocks sequentially? For this you can use the <a href="../ref/Typography.html#paginate()">paginate()</a> command. It accepts an identical set of arguments to the <i>text()</i> command, but rather than returning a single <i>Text</i> object, it returns a generator from which you can pluck <i>Text</i> after <i>Text</i> until your string has been fully laid out.</p>

    <p>Unlike the <i>text()</i> command, calling <i>paginate()</i> does <b>not</b> draw anything to the canvas. Instead, it allows you to iterate over its return value and manually <a href="../ref/Canvas.html#plot()">plot()</a> each <i>Text</i> object individually at the time of your choosing. For example, here we're not plotting the text at all, merely logging the details of each "page" to the console:</p>

    <div class="example">
      <pre>
size(8.5, 11, inch)
for page in paginate(1,1, 6.5,9, src='http://plotdevice.io/data/poe.txt'):
    print(page)
>>> Text(chars=733 overflow=12335 idx=0 folio=1)
>>> Text(chars=808 overflow=11527 idx=1 folio=2)
>>> Text(chars=716 overflow=10811 idx=2 folio=3)
>>> Text(chars=410 overflow=10401 idx=3 folio=4)
>>> Text(chars=471 overflow=9930 idx=4 folio=5)
>>> ...
>>> Text(chars=588 overflow=608 idx=18 folio=19)
>>> Text(chars=608 idx=19 folio=20)
</pre>
    </div>

    <p>Note that the objects returned by the generator have a pair of extra properties not typically present on <i>Text</i> objects:</p>
    <ul>
      <li><i>idx</i> – the page's sequence number (counting up from zero)</li>
      <li><i>folio</i> - the logical "page number" (counting up from 1 or an alternate starting value specified through <i>paginate</i>'s <code>folio</code> keyword argument)</li>
    </ul>

    <p>With these tools in hand we have just about everything necessary to do some decent book typesetting. In this example we're using the <a href="../ref/Canvas.html#multi-page-pdfs">multi-page PDF</a> capabilities of the <i>export()</i> command in tandem with the <i>paginate()</i> command to generate a quick-and-dirty ebook:</p>

    <div class="example">
      <pre>
with export('~/poe.pdf') as book:
    # pick a nice trade paperback-y size so we can use WIDTH & HEIGHT for layout
    size(6, 9, inch)

    # map styles to tag-names in our marked-up XML file
    url = 'http://plotdevice.io/data/poe.xml'
    stylesheet('title', align=CENTER)
    stylesheet('author', indent=0, align=CENTER, italic=True)
    stylesheet('em', italic=True)

    # set up the typesetting basics
    font('Hoefler Text', 12, osf=1)
    layout(leading=1.4, indent=1.4, hyphenate=True)

    # load the XML and draw each page-worth of text to the PDF
    for pg in paginate(.75, .75, WIDTH-1.5, HEIGHT-1.5, src=url):
        with book.page:
            plot(pg) # draw the page
            with layout(align=CENTER):
                text(WIDTH/2, HEIGHT-.5, str=pg.folio) # draw the folio
</pre>
    </div>

    <p class="double-dagger">There is one big caveat to keep in mind when exporting text-heavy compositions to multiple pages. Quartz's font subsetting routines optimize for the single-page case so your resulting PDF is likely to have a <i>ton</i> of redundant font data baked into every page. To get the file size down to something reasonable, we recommend running the generated PDF through Acrobat's <span class="message">File &rarr; Save As &rarr; Optimized PDF</span> menu item before distributing it.</p>

  </div>

</body></html>