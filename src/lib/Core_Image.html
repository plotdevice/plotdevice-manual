<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

  <title></title>

</head><body>
  <div class="article">
    <h2>Description</h2>

    <p>The Core Image library for PlotDevice adds image manipulation to PlotDevice. It’s like having
    control over Photoshop through simple Python programming commands. <a href="http://www.apple.com/macosx/features/coreimage/">Core Image</a> is a Mac OS X specific
    framework available from Mac OS X 1.4 (Tiger) and up (Leopard, ...). Core Image uses hardware
    acceleration whenever possible. You can apply filters and transformations to images with a
    real-time and interactive response. And, since all of the image manipulations are stored in a
    script, the process is <i>non-destructive</i>. The source images remain unchanged. The script
    is a recipe you can reuse on different source images.</p>
    <h2>Download</h2>

    <table border="0">
      <tbody>
        <tr>
          <td><a href="http://plotdevice.io/libs/coreimage.zip"><img alt="download" height="20" src="../etc/lib/download.gif" width="20"/></a>
          </td><td><a href="http://plotdevice.io/libs/coreimage.zip">coreimage.zip</a>
          (1.4MB)<br/>
          <i>Last updated for NodeBox 1.9.5<br/>
          Licensed under GPL<br/></i><i>Author: Tom De Smedt</i><br/>
        </td></tr></tbody></table>

    <h2>Documentation</h2>

    <ul>
      <li><a href="#loading_the_library">How to get the library up and running</a>
      </li><li><a href="#creating_a_canvas">Creating a new canvas</a>
      </li><li><a href="#adding_layers">Adding new layers to the canvas</a>
      </li><li><a href="#arranging_layers">Retrieving and arranging layers</a>
      </li><li><a href="#transforming_layers">Moving and transforming layers</a>
      </li><li><a href="#layers_adjustments">Adjusting layer brightness, contrast and saturation</a>
      </li><li><a href="#blend_modes">Layer opacity and blending modes</a>
      </li><li><a href="#alpha_masks">Applying alpha masks</a>
      </li><li><a href="#filters">Layer filters</a>
      </li><li><a href="#dropshadows">Layer dropshadows</a><br/>
      </li><li><a href="#pixels">Working with layer pixels</a>
      </li><li><a href="#export_the_canvas">Exporting the canvas to JPEG, GIF, PNG or TIFF</a>
      </li><li><a href="#drawing_the_canvas">Drawing the canvas in PlotDevice</a>
      </li><li><a href="#helpers">Working with helpers and interfaces</a>
      </li><li><a href="#morguefile">Working with images from MorgueFile</a>
      </li><li><a href="#dynamics">Working with dynamics and caching</a><br/>
      </li><li><a href="#issues">Known issues and limitations</a><br/>
    </li></ul>

    <p> </p>
    <hr/>

    <h2><a id="loading_the_library" name="loading_the_library" title="loading_the_library"></a>How
    to get the library up and running</h2>

    <p>Put the <i>coreimage</i> library folder in the same folder as your script so PlotDevice can
    find the library. It takes some time to load the library the first time.</p>
<pre>coreimage = ximport("coreimage")
</pre>

    <p> </p>
    <hr/>

    <h2><a id="creating_a_canvas" name="creating_a_canvas" title="creating_a_canvas"></a>Creating a
    new canvas</h2>

    <p>The <i>canvas()</i> command returns a new, empty canvas. It takes two parameters: the
    <i>width</i> and <i>height</i> of the canvas. You can set an optional <i>quality</i> parameter
    to ‘high’ to use 128-bit pixel depth but this is unnecessary in most cases.</p>
<pre>canvas = coreimage.canvas(150, 150)
</pre>

    <p> </p>
    <hr/>

    <h2><a id="adding_layers" name="adding_layers" title="adding_layers"></a>Adding new layers to
    the canvas</h2>

    <p>A canvas is a container of many layers which you can position, scale , rotate, blend,
    filter, etc. You can create layers from image files, fill colors, linear or radial gradients,
    paths (ovals, text, ...), lists of pixels colors, another layer or canvas (i.e. a group of
    layers), or Quicktime movie frames.</p>
    <p> </p>
    <p><span class="grey_box">canvas.append()</span></p>
    <p>The <i>canvas.append()</i> method adds a new layer to the top of the canvas. It is placed at
    the center of the canvas by default.</p>
<pre>canvas.append(filename)
</pre>
<pre>canvas.append(clr)
</pre>
<pre>canvas.append(clr1, clr2, type="linear", spread=0.0)
</pre>
<pre>canvas.append(path, background=None, fill=None, stroke=None, strokewidth=None)
</pre>
<pre>canvas.append([clr1, clr2, clr3, ...], w, h)
</pre>
<pre>canvas.append(layer)
</pre>
<pre>canvas.append(canvas)
</pre>
<pre>canvas.append(layer.render())
</pre>
<pre>canvas.append(canvas.flatten())
</pre>
<pre>canvas.append(open(filename).read())
</pre>
<pre>canvas.append(movieframe)
</pre>

    <p> </p>
    <p><span class="grey_box">Examples</span></p>
    <p>Consider we have the following images, <i>leaf.jpg</i> and <i>lily.tif</i>.
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-leaf.jpg" width="150"/><br/>
          <a href="../etc/lib/leaf.jpg">leaf.jpg</a>
          </td><td><a href="../etc/lib/lily.tif"><img height="150" src="../etc/lib/coreimage-lily.jpg" width="150"/><br/>
          lily.tif</a>
        </td></tr></tbody></table></p>
    <p>Core Image can use JPEG, GIF, PNG and TIFF images. If you are using images with an alpha
    channel the best way to import them is as transparent TIFF and not as a PNG (which can have
    jagged edges in Core Image).</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers1.jpg" width="150"/>
          </td><td>
            A canvas with two layers from image files is easy enough:
<pre>
l = canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
canvas.draw()
</pre>The <i>canvas.append()</i> method has four ptional parameters: the <i>x</i> and <i>
            y</i> position in pixels and <i>w</i> and <i>h</i> dimensions in pixels. The command
            returns the layer object.
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers2.jpg" width="150"/>
          </td><td>
            Opaque fill layers are created from a standard PlotDevice <a href="../ref/Line+Color.html#color()">color()</a>. The layer will fill the entire canvas by
            default.
<pre>
l = canvas.append(color(1.0, 0.0, 0.5))
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers3.jpg" width="150"/>
          </td><td>
            <a href="../tut/Bezier_Paths.html">Paths</a> from PlotDevice can be transformed to a pixel layers
            as well. The <i>canvas.append()</i> method has optional path parameters: <i>fill</i>,
            <i>background</i>, <i>stroke</i> (black, transparent and transparent colors by default)
            and <i>strokewidth</i>.
<pre>
l = canvas.append(color(1.0, 0.0, 0.5))
</pre>font(’Georgia-Italic’, 40)<br/>
            p = textpath(’text’, 0, 0)<br/>
            l = canvas.append(p, fill=color(1))<br/>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers4.jpg" width="150"/>
          </td><td>
            Linear gradients can be defined as two colors:<br/>
<pre>
l = canvas.append(color(1), color(0))
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers5.jpg" width="150"/>
          </td><td>
            Both linear and radial gradients are defined by two colors. If you also define the
            optional <i>type</i> parameter as ‘radial’ you get a radial gradient. You control the
            range of the gradient center with the optional <i>spread</i> parameter (between 0.0 and
            1.0).
<pre>
l = canvas.append(color(1), color(0), type="radial")
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers6.jpg" width="150"/>
          </td><td>
            You can also pass another canvas as a new layer. This way you have a subgroup of layers
            that stick together.
<pre>
l = canvas.append(color(0))
group = coreimage.canvas(100, 100)
group.append("leaf.jpg")
group.append("lily.tif")
l = canvas.appebd(group)
l.rotate(45)
</pre>
        </td></tr><tr>
          <td><img alt="coreimage-layers7b" height="150" src="../etc/lib/coreimage-layers7b.jpg" width="150"/><br/>
          </td><td>
            If you have some byte data, for example image data downloaded from a site with the
            <a href="Web.html">Web</a> library:
<pre>
web = ximport("web")
url = "http://nodebox.net/code/g/header.jpg"
image_data = web.download(url)
canvas = coreimage.canvas(150, 150)
canvas.append(image_data, x=-190)
</pre>
        </td></tr><tr>
          <td><img alt="coreimage-layers7c" height="150" src="../etc/lib/coreimage-layers7c.jpg" width="150"/>
          </td><td>
            A layer from individual pixels can be created by supplying a list of colors and a width
            and a height (thanks to Duane Bailey):
<pre>
def fractal(x, y, depth=64):
    z = complex(x, y)
    o = complex(0, 0)
    for i in range(depth):
        if abs(o) &lt;= 2: o = o*o + z
        else:
            return i
    return 0 #default, black

pixels = []
w = h = 150
for i in range(w):
    for j in range(h):
        v = fractal(float(i)/w, float(j)/h)
        pixels.append(color(v/10.0, v/20.0, v/10.0))

l = canvas.append(pixels, w, h)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>If you think <i>canvas.append()</i> is too generic, there are various aliases that make it
    more understandable what kind of layer you’re creating (all return a new layer):
    <i>canvas.fill()</i>, <i>canvas.path()</i>, <i>canvas.gradient()</i>, <i>canvas.group()</i>,
    <i>canvas.bytes()</i>, <i>canvas.pixels()</i>.</p>
    <p> </p>
    <p><span class="grey_box">Layer copies</span></p>
    <p>Existing layers in a canvas can be duplicated. The copy appears right above the duplicated
    layer:</p>
<pre>l = canvas.append("leaf.jpg")
dupl = l.duplicate()
</pre>

    <p>You can copy layers from one canvas and append them to another canvas:</p>
<pre>offscreen = coreimage.canvas(150,150)
l = offscreen.append("leaf.jpg").copy()
canvas.append(l)
</pre>

    <p>You can pre-render layers with <i>layer.render()</i> (or a canvas with
    <i>canvas.flatten()</i>) once and then use them as new layers or in another canvas. The
    advantage is that all the transformations and filters are calculated only once instead of
    individually for each copy. You can think of this as ‘flattening’ a layer. See also the chapter
    on <a href="#dynamics">dynamics and caching</a>.</p>
    <p> </p>
    <p><span class="grey_box">Layer type</span></p>
    <p>You can check what type of layer you are working with using the following properties:</p>
    <ul>
      <li><i>layer.is_file</i>: a layer created from an image file.
      </li><li><i>layer.is_fill</i>: an opaque fill color.
      </li><li><i>layer.is_gradient</i>: a linear or radial gradient.
      </li><li><i>layer.is_linear_gradient</i>: a linear gradient.
      </li><li><i>layer.is_radial_gradient</i>: a radial gradient.
      </li><li><i>layer.is_path</i>: a layer created from a PlotDevice path.
      </li><li><i>layer.is_pixels</i>: a layer created from a list of colors.<br/>
      </li><li><i>layer.has_layers</i>: a layer created from a canvas object.
      </li><li><i>layer.has_shadow</i>: a dropshadow will be rendered for this layer.<br/>
      </li><li><i>layer.is_mask</i>: a layer that is part of the alpha mask of another layer.
    </li></ul>
<pre>l = canvas.append("leaf.jpg")
print l.is_file
&gt;&gt;&gt; True
</pre>

    <p> </p>
    <hr/>

    <h2><a id="arranging_layers" name="arranging_layers" title="arranging_layers"></a>Retrieving
    and arranging layers</h2>

    <p>A canvas object acts as a list of layers. With a for-loop you can address each layer it
    contains:
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers7.jpg" width="150"/>
          </td><td>
<pre>
for i in range(20):
    canvas.append("lily.tif")

for layer in canvas:
    layer.x = random(canvas.w)
    layer.y = random(canvas.h)
</pre>
          </td></tr></tbody></table></p>
    <p>Layers can be named and easily retrieved later on. The <i>canvas.append()</i> method has an
    optional <i>name</i> parameter. You can then search the canvas for layer names with the
    recursive <i>canvas.find()</i> command or address layers as canvas properties:</p>
<pre>canvas.append("leaf.jpg", name="bg")
l = canvas.find("bg")
print l.name, l.x, l.y
&gt;&gt;&gt; bg, 75, 75
</pre>
<pre>canvas.append("leaf.jpg", name="bg")
l = canvas.bg
</pre>             

    <p> </p>
    <p><span class="grey_box">Layer order</span></p>
    <p>Each new layer is added to the top of the canvas. You can change the ordering of a layer
    with the following commands:</p>
    <ul>
      <li><i>layer.up()</i>: moves the layer up one position in the layer stack
      </li><li><i>layer.down()</i>: moves the layer down one position in the layer stack
      </li><li><i>layer.to_front()</i>: moves the layer to the foreground of the canvas
      </li><li><i>layer.to_back()</i>: moves the layer to the background of the canvas
    </li></ul>

    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers8.jpg" width="150"/>
          </td><td>
<pre>
back = canvas.append("leaf.jpg")
front = canvas.append("lily.tif")
back.to_front()
</pre>
          </td></tr></tbody></table></p>
    <p>The <i>layer.index</i> property contains the layer’s position in the canvas. Like any list
    in PlotDevice the indices start from zero:</p>
<pre>canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
print l.index
&gt;&gt;&gt; 1
</pre>

    <p>The <i>layer.hide()</i> method excludes the layer from the output:</p>
<pre>canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.hide()
</pre>

    <p> </p>
    <hr/>

    <h2><a id="transforming_layers" name="transforming_layers" title="transforming_layers"></a>Moving and transforming layers</h2>

    <p>Individual layers in the canvas can be moved, scaled, rotated, flipped, distorted and
    cropped.
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers9.jpg" width="150"/>
          </td><td>
            You can use a layer’s <i>x</i> and <i>y</i> properties to move it around. These
            properties store the layer’s position measured in pixels from the top-left of the
            canvas.
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.x = 0
l.y = 0
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers10.jpg" width="150"/>
          </td><td>
            The same can be achieved using the <i>layer.translate()</i> method. This command
            accepts two parameters, either absolute pixel values or relative positions between 0.0
            and 1.0.
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.translate(1.0, 1.0)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers11.jpg" width="150"/>
          </td><td>
            You can scale images using pixel size or relative size. By supplying two parameters you
            can scale width and height individually.
<pre>
canvas.append("leaf.jpg")
for i in range(10):
    l = canvas.append("lily.tif")
    l.x = i*20
    l.scale(1.0 - i*0.1)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers12.jpg" width="150"/>
          </td><td>
            Rotating layers is just as easy:<br/>
<pre>
canvas.append("leaf.jpg")
for i in range(10):
    l = canvas.append("lily.tif")
    l.rotate(i*10)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers13.jpg" width="150"/>
          </td><td>
            There’s also the <i>layer.flip_vertical()</i> and <i>layer.flip_horizontal()</i>
            methods of course.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif").flip_vertical()
</pre>
            <p><i><br/></i></p>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers14.jpg" width="150"/>
          </td><td>
            The <i>layer.distort()</i> method has optional <i>dx0</i>, <i>dy0</i>, <i>dx1</i>,
            <i>dy1</i>, <i>dx2</i>, <i>dy2</i>, <i>dx3</i>, <i>dy3</i> parameters setting the
            displacement of the left top, right top, right bottom and left bottom corners of the
            layer (in pixels or between 0.0 and 1.0).
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.distort(dy0=-500, dx2=-100)
</pre><br/>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers65" height="150" src="../etc/lib/coreimage-layers65.jpg" width="150"/></span><br/>
          </td><td>
            The <i>layer.crop()</i> cuts a box from the image, starting from the top left position,
            with the given width and height. Images are always cropped before they are rotated,
            scaled and distorted.
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.crop(0, 0, 80, 80)
</pre>          
          </td></tr></tbody></table></p>
    <p> </p>
    <p><span class="grey_box">Origin point</span></p>
    <p>By default, all layer transformations originate from the layer’s center. However, you can
    change the layer’s origin point, have the layer rotate from the bottom right corner for
    example. Let’s turn on some of the visual aids in the Core Image library for a minute:</p>
<pre>canvas.draw(helper=True)
</pre>

    <p> </p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-layers16.jpg" width="751"/></span></p>
    <p>We can clearly see the layer’s bounding box and how it is positioned around the central
    origin point. The layer rotates from the center. When we call <i>layer.origin_bottom_left()</i>
    to change the layer’s origin point to the bottom left, rotations will originate from over
    there. Also, now the layer’s bottom left is at the center of the canvas instead of the layer’s
    center. Think of the origin point as the layer’s anchor/pivot/orbit.</p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-layers17.jpg" width="751"/></span></p>
    <p>The following commands set the origin point:</p>
    <ul>
      <li><i>layer.origin_top_left()</i>
      </li><li><i>layer.origin_top_right()</i>
      </li><li><i>layer.origin_top_center()</i>
      </li><li><i>layer.origin_bottom_left()</i>
      </li><li><i>layer.origin_bottom_right()</i>
      </li><li><i>layer.origin_bottom_center()</i>
      </li><li><i>layer.origin_left_center()</i>
      </li><li><i>layer.origin_right_center()</i>
      </li><li><i>layer.origin_center()</i>
    </li></ul>

    <p>Or you can just use <i>layer.origin()</i> to set it yourself:</p>
<pre>print l.origin(0.23, 1.07)
&gt;&gt;&gt; (0.23, 1.07)
</pre>

    <p> </p>
    <p><span class="grey_box">Layer bounds</span></p>
    <p>To get the bounding box coordinates of layer, use <i>layer.bounds()</i>:</p>
<pre>print l.bounds()
&gt;&gt;&gt; (200.0, 78.647456721610681, 409.52033810627165, 288.167787843871)
</pre>

    <p>To get the width and height of a transformed layer, use <i>layer.size()</i> or the
    <i>width</i> and <i>height</i> properties. Note that when you manipulate the layer with filters
    the actual rendered pixels may fall beyond the given bounds.</p>
<pre>w, h = l.size()
print w, h
&gt;&gt;&gt; (209.52033810627165, 209.5203311222603)
</pre>
<pre>print l.width
print l.height
</pre>

    <p>You can easily position a layer at the center of the canvas with the <i>layer.center()</i>
    method:</p>
<pre>l.center()
</pre>           

    <p> </p>
    <hr/>

    <h2><a id="layers_adjustments" name="layers_adjustments" title="layers_adjustments"></a>Adjusting layer brightness, contrast and saturation</h2>

    <p>Aside from placing and transforming multiple layers in a canvas, we can also modify the
    color information in each layer.</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers18.jpg" width="150"/>
          </td><td>
            The layer’s <i>brightness</i> property ranges between -1.0 and 1.0:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.brightness = 0.25
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers19.jpg" width="150"/>
          </td><td>
            The layer’s <i>contrast</i> property ranges between 0.25 and 4.0:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.contrast = 1.5
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers20.jpg" width="150"/>
          </td><td>
            The layer’s <i>saturation</i> property ranges between 0.0 and 2.0:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.saturation = 2.0
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers21.jpg" width="150"/>
          </td><td>
            The <i>layer.desaturate()</i> method removes all color information:<br/>
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.desaturate()
print l.saturation
&gt;&gt;&gt; 0.0
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers22.jpg" width="150"/>
          </td><td>
            The <i>layer.invert()</i> method inverts all colors in the layer:
<pre>
l = canvas.append("leaf.jpg")
l.invert()
l = canvas.append("lily.tif")
l.invert()
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>You can set a combination of brightness, contrast and saturation with the
    <i>layer.adjust()</i> method, which has three optional parameters <i>brightness</i>,
    <i>contrast</i> and <i>saturation</i>.</p>
    <p> </p>
    <hr/>

    <h2><a id="blend_modes" name="blend_modes" title="blend_modes"></a>Layer opacity and blending
    modes</h2>

    <p>Layers can be composited by adjusting their individual transparency or by applying blend
    modes to create all sorts of effects.</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers23.jpg" width="150"/>
          </td><td>
            The <i>layer.blend()</i> command takes one parameter ranging between 0 and 100 or
            between 0.0 and 1.0:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.blend(25)
print l.opacity
&gt;&gt;&gt; 0.25
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers24.jpg" width="150"/>
          </td><td>
<pre>
canvas.append("leaf.jpg")
for i in range(10):
    l = canvas.append("lily.tif")
    l.scale(0.5)
    l.x = random(canvas.w)
    l.y = random(canvas.h)
    l.blend(random())
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers25.jpg" width="150"/>
          </td><td>
            Screen blend displays pixels that are lighter than those underneath.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif", x=50)
l = canvas.append("lily.tif", x=100)
l.blend_screen()
</pre>
            <p>A similar effect is <i>layer.blend_lighten()</i>.</p>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers26.jpg" width="150"/>
          </td><td>
            Multiply blend displays pixels that are darker than those underneath.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif", x=50)
l = canvas.append("lily.tif", x=100)
l.blend_multiply()
</pre>
            <p>A similar effect is <i>layer.blend_darken()</i>.</p>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers27.jpg" width="150"/>
          </td><td>
            Overlay uses a combination of screen and multiply.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif", x=50)
l = canvas.append("lily.tif", x=100)
l.blend_overlay()
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers27b.jpg" width="150"/>
          </td><td>
            Soft light uses a combination of darken and lighten.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif", x=50)
l = canvas.append("lily.tif", x=100)
l.blend_softlight()
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers27c.jpg" width="150"/>
          </td><td>
            Hard light uses a combination of screen and multiply.
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif", x=50)
l = canvas.append("lily.tif", x=100)
l.blend_hardlight()
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers28.jpg" width="150"/>
          </td><td>
            Applying the hue of the blend layer to layers underneath:
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif")
l = canvas.append(color(1.0,0.0,0.5))
l.blend_hue(50)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers29.jpg" width="150"/>
          </td><td>
            Applying the hue and saturation of the blend layer to layers underneath:
<pre>
canvas.append("leaf.jpg")
canvas.append("lily.tif")
l = canvas.append(color(1.0,0.0,0.5))
l.blend_color(50)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>Use the <i>layer.blendmode</i> property to check what blending mode the layer is using.</p>
<pre>print l.blendmode
&gt;&gt;&gt; multiply
</pre>

    <p>You can set the opacity and blend mode together with the <i>layer.blend()</i> command:</p>
<pre>l.blend(25, mode="multiply")
print l.opacity, l.blendmode
&gt;&gt;&gt; 0.25, color
</pre>
<pre>l.blend("multiply")
</pre>

    <p>The <i>layer.blend_normal()</i> command removes any blend mode from the layer.</p>
    <p> </p>
    <hr/>

    <h2><a id="alpha_masks" name="alpha_masks" title="alpha_masks"></a>Applying alpha masks</h2>

    <p>The layer’s alpha mask stores information where the layer shines through and where it is
    opaque. Since the <i>layer.mask</i> property is a canvas object, it’s just as easy to work with
    alpha layers than it is with normal layers. You can position, transform, adjust, blend and
    filter them just as any other layer.</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers30.jpg" width="150"/>
          </td><td>
            Applying a linear gradient alpha mask to the lily:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
m = l.mask.gradient()
m.rotate(45)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers31.jpg" width="150"/>
          </td><td>
            Using a PlotDevice path as a mask:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
font("Georgia-Italic", 50)
p = textpath("text", 0, 0)
m = l.mask.append(p)
m.y += 25
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers32.jpg" width="150"/>
          </td><td>
            Using the lily as a mask for a gradient layer:
<pre>
canvas.append(color(0.4,0.0,0.2))
pink = color(1.0,0.0,0.5)
white = color(1.0,1.0,1.0)
l = canvas.gradient(pink, white)
l.mask.append("lily.tif")
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers33.jpg" width="150"/>
          </td><td>
            Complex mask made up of multiple layers:
<pre>
l = c.gradient(pink, white)
for i in range(3):
    m = l.mask.append("lily.tif")
    m.scale(1-i*0.4)
    m.rotate(20*i)
    m.blend("softlight")
    m.filter("zoomblur", amount=i*25)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <hr/>

    <h2><a id="filters" name="filters" title="filters"></a>Layer filters</h2>

    <p>The Core Image library supports a number of filters that manipulate the pixels in a layer.
    Blur and sharpen are standard so you can set these as properties:</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-layers34.jpg" width="150"/>
          </td><td>
            The <i>layer.blur</i> takes one parameter ranging between 0.0 and 100.0:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.blur = 2
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers35.jpg" width="150"/>
          </td><td>
            Sharpening the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.sharpen = 10
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-layers36.jpg" width="150"/>
          </td><td>
            Other filters use the <i>layer.filter()</i> method:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("zoomblur", dx=25)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Filter reference</span></p>
    <p>There are many other filters like the zoom blur above. Each <i>layer.filter()</i> command
    takes its own optional parameters to tweak. Scroll down for visual examples.<br/></p>
    <p><b>Zoom blur</b><br/>
    Simulates the effect of zooming the camera while capturing the layer. Parameters are <i>dx</i>,
    <i>dy</i> and <i>amount</i> ranging between 0.0 and 200.0.</p>
<pre>layer.filter("zoomblur", amount=20, dx=0, dy=0)
</pre>

    <p><b>Motion blur</b><br/>
    Simulates a directional blur. Parameters are <i>radius</i> between 0.0 and 100.0 and
    <i>angle</i>.</p>
<pre>layer.filter("motionblur", radius=20, angle=0)
</pre>

    <p><b>Noise reduction</b><br/>
    Edges in the layer below a threshold are blurred, edges above are sharpened. Parameters are
    noise between 0.0 and0.1 and sharpness between 0.0 and 2.0.<br/></p>
<pre>layer.filter("noisereduction", noise=0.02, sharpness=0.4
</pre>

    <p><b>Bump distortion</b><br/>
    Creates a bump or pinch from a point in the layer. Parameters are <i>dx</i>, <i>dy</i>,
    <i>radius</i> between 0.0 and 600.0 and <i>scale</i> between -1.0 and 1.0.</p>
<pre>layer.filter("bumpdistortion", dx=0, dy=0, radius=300, scale=0.5)
</pre>

    <p><b>Bump distortion</b> <b>linear | stretch</b> (Mac OS X 10.5 and up)<br/>
    Creates a bump or pinch from a line in the layer. Parameters are <i>dx</i>, <i>dy</i>,
    <i>radius</i> between 0.0 and 600.0,  <i>scale</i> between -1.0 and 1.0 and <i>angle</i>.</p>
<pre>layer.filter("stretch", dx=0, dy=0, radius=300, scale=0.5, angle=0)
</pre>

    <p><b>Hole distortion</b><br/>
    Pushes the layer’s pixels outwards. Parameters are <i>dx</i>, <i>dy</i>, and a <i>radius</i>
    between 0.0 and 1000.0.</p>
<pre>layer.filter("holedistortion", dx=0, dy=0, radius=300)
</pre>

    <p><b>Circle splash distortion</b><br/>
    Pushes the layer’s pixels outwards on a circle. Parameters are <i>dx</i>, <i>dy</i>,
    <i>radius</i> between 0.0 and 1000.0 .<br/></p>
<pre>layer.filter("circlesplash", dx=0, dy=0, radius=150)
</pre>

    <p><b>Twirl distortion<br/></b>Generates a wave motion in the layer. Parameters are <i>dx</i>,
    <i>dy</i>, <i>radius</i> between 0.0 and 500.0 and <i>angle</i>.</p>
<pre>layer.filter("twirl", dx=0, dy=0, radius=150, angle=100)
</pre>

    <p><b>Circular wrap</b><br/>
    Wraps the layer around a transparent circle. Parameters are <i>radius</i> between 0.0 and 500.0
    and <i>angle</i>.</p>
<pre>layer.filter("circularwrap", radius=150, angle=100)
</pre>

    <p><b>Kaleidoscope</b><br/>
    Generates fractal-like output. Parameters are <i>dx</i>, <i>dy</i> and <i>count</i> between 0
    and 100.</p>
<pre>layer.filter("kaleidoscope", dx=0, dy=0, count=10)
</pre>

    <p><b>Triangle tile</b><br/>
    Generates fractal-like output. Parameters are <i>dx</i>, <i>dy</i> and <i>angle</i> and
    <i>width</i>.</p>
<pre>layer.filter("triangletile", dx=0, dy=0, angle=10, width=100)
</pre>

    <p><b>Parallelogram tile</b> (Mac OS X 10.5 and up)<br/>
    Generates fractal-like output. Parameters are <i>dx</i>, <i>dy</i> and <i>angle</i>,
    <i>width</i> and <i>tilt</i> angle.<br/></p>
<pre>layer.filter("parallelogramtile", dx=0, dy=0, angle=10, width=100, tilt=90)
</pre>

    <p><b>Perspective tile</b><br/>
    Distorts the base layer and copies that on a plane. Parameters are <i>dx0</i>, <i>dy0</i>,
    <i>dx1</i>, <i>dy1</i>, <i>dx2</i>, <i>dy2</i>, <i>dx3</i>, <i>dy3</i> representing the corners
    of the layer to distort.</p>
<pre>layer.filter("perspectivetile", dx0=0, dy0=0, dx1=0, dy1=0,
                                dx2=0, dy2=0, dx3=0, dy3=0)
</pre>

    <p><b>Starshine generator</b><br/>
    A generator that creates stars and sunbursts on the layer (which is usually a transparent
    color). Parameters are <i>dx</i>, <i>dy</i>, <i>radius</i> between 0.0 and 300.0,
    <i>x_scale</i> between 0.0 and 100.0, <i>x_angle</i>, <i>x_width</i> and <i>epsilon</i> between
    -8.0 and 8.0.</p>
<pre>layer.filter("starshine", dx=0, dy=0, radius=25,
                          x_scale=10, x_angle=0, x_width=0.5, epsilon=-5.0)
</pre>

    <p><b>Checkerboard generator</b><br/>
    A generator that creates a checkerboard pattern on the layer (which is usually a transparent
    color). Parameters are clr1 and clr2 (black and white by default), width between 0.0 and 800.0,
    and sharpness between 0.0 and 1.0.</p>
<pre>layer.filter("checkerboard", clr1=color(0), clr2=color(1),
                             width=80, sharpness=1.0)
</pre>

    <p><b>Bloom</b><br/>
    Adds a hazy glow to the layer by softening the edges. Parameters are <i>radius</i> between 0.0
    and 100.0 and <i>intensity</i> between 0.0 and 1.0.</p>
<pre>layer.filter("bloom", radius=10, intensity=1.0)
</pre>

    <p><b>Pixelate</b><br/>
    Divides the image into rectangular cells. It takes one optional parameter <i>scale</i> between
    1.0 and 100.0</p>
<pre>layer.filter("pixelate", scale=8)
</pre>

    <p><b>Crystallize</b><br/>
    Divides the image into polygonal cells. It takes one optional parameter <i>radius</i> between
    1.0 and 100.0</p>
<pre>layer.filter("crystallize", radius=20)
</pre>

    <p><b>Dotscreen</b><br/>
    Simulates the dot patterns of a halftone screen. Parameters are <i>dx</i>, <i>dy</i>,
    <i>angle</i> between 0 and 360, <i>width</i> between 1 and 50, and <i>sharpness</i> between 0.0
    and 1.0.</p>
<pre>layer.filter("dotscreen", dx=0, dy=0, angle=0, width=6, sharpness=0.7)
</pre>

    <p><b>Lighting</b><br/>
    Adds a light source to the layer. Parameters are <i>dx0</i>, <i>dy0</i>, <i>dz0</i> between 0
    and 1000 represting the height of the light source, <i>dx1</i> and <i>dy1</i> representing
    where the light is shining, <i>brightness</i> between 0.0 and 10.0, <i>concentration</i>
    between 0.0 and 1.0 representing the cone of the light beam and <i>color</i>.</p>
<pre>layer.filter("lighting", dx0=100, dy0=100, dz0=300, dx1=0, dy1=0,
                         brightness=3.0, concentration=0.3,
                         color=None, helper=False)
</pre>

    <p><b>Shading</b><br/>
    Adds texturing to the layer. You can pass it a canvas object to apply as a texture. Parameters
    are <i>dx</i>, <i>dy</i>, <i>radius</i> between 0.0 and 300.0 and <i>texture</i> which is a
    canvas object.</p>
<pre>layer.filter("shading", radius=20, texture=None, dx=0, dy=0)
</pre>

    <p><b>Line overlay</b> (Mac OS X 10.5 and up)<br/>
    Simulates a sketch of the layer by outlining the edges in black, after performing noise
    reduction. Parameters are <i>noise</i> between 0.0 and 0.01, <i>sharpness</i> between 0.0 and
    2.0, <i>intensity</i> between 0 and 200 and <i>contrast</i> between 25 and 200.</p>
<pre>layer.filter("lineoverlay", noise=0.07, sharpness=0.71
                            intensity=1.0, threshold=0.1, contrast=50)
</pre>

    <p><b>Page curl</b><br/>
    Curls a corner of the layer. You can pass the <i>back</i> parameter a canvas object to use as
    backside. By default the backside is a mirrored version of the layer. It can also be a color or
    ‘pattern’, in which case the backside is a triangle-tiled pattern. Parameters are <i>time</i>
    between 0.0 and 1.0, <i>radius</i> between 0 and 200 and <i>angle</i> between 0 and 360.</p>
<pre>layer.filter("pagecurl", time=0.4, radius=75, angle=45, back=None)
</pre>

    <p><b>Levels</b><br/>
    Provides control over each RGBA color channel in the layer. Parameters are <i>r</i>, <i>g</i>,
    <i>b</i> and <i>a</i> which can be numbers between 0.0 and 1.0 or four-tuples if you want to do
    complex things like increase the blue inside the R channel.</p>
<pre>layer.filter("levels", r=1.0, g=1.0, b=.0, a=.0)
</pre>

    <p><b>Edges</b><br/>
    Finds all the edges in an image and displays them in a color.</p>
<pre>layer.filter("edges", intensity=1.0)
</pre>             

    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers37.jpg" width="150"/></span>
          </td><td>
            Applying the zoom blur to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("zoomblur", dy=25)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers38.jpg" width="150"/></span>
          </td><td>
            Applying the motion blur to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("motionblur", angle=45, radius=50)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers38b" height="150" src="../etc/lib/coreimage-layers38b.jpg" width="150"/></span>
          </td><td>
             Applying noise reduction to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("noisereduction", noise=0.01, sharpness=1.0)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers39.jpg" width="150"/></span>
          </td><td>
            Applying bump distortion to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("bumpdistortion", scale=0.75, dy=-35)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers38c" height="150" src="../etc/lib/coreimage-layers38c.jpg" width="150"/></span>
          </td><td>
             Applying linear bump distortion to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("stretch", radius=60, scale=0.0, dy=60)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers39b.jpg" width="150"/></span>
          </td><td>
            Applying hole distortion to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("holedistortion", radius=40)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers59" height="150" src="../etc/lib/coreimage-layers59.jpg" width="150"/></span><br/>
          </td><td>
            Applying circle splash distortion to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("circlesplash", radius=45)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers40.jpg" width="150"/></span>
          </td><td>
            Applying the famous twirl filter to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("twirl", radius=150)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers57" height="150" src="../etc/lib/coreimage-layers57.jpg" width="150"/></span><br/>
          </td><td>
            Applying the circular wrap filter to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("twirl", radius=150)
</pre>             
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers41.jpg" width="150"/></span>
          </td><td>
            Applying a kaleidoscope to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("kaleidoscope", count=5)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers42b" height="150" src="../etc/lib/coreimage-layers42b.jpg" width="150"/></span>
          </td><td>
            Applying a triangle tile to the layer:
<pre>
l = c.append("lily.tif")
l.filter("triangletile", dx=-30, dy=-30, width=40)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers42c" height="150" src="../etc/lib/coreimage-layers42c.jpg" width="150"/></span><br/>
          </td><td>
             Applying a parallelogram tile to the layer:
<pre>
l = c.append("lily.tif")
l.filter("triangletile", dx=3, width=40, tilt=-45)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers42.jpg" width="150"/></span>
          </td><td>
            Applying a perspective tile to the layer:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.scale(0.6)
l.filter("perspectivetile", dx0=50, dy1=30, dy2=-50)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers43.jpg" width="150"/></span>
          </td><td>
            Generating starshine:
<pre>
canvas.append("leaf.jpg")
l = canvas.append(color(0, 0))
l.filter("starshine", x_width=0.3)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers58" height="150" src="../etc/lib/coreimage-layers58.jpg" width="150"/></span><br/>
          </td><td>
            Generating a checkerboard pattern:
<pre>
l = canvas.append(color(0, 0))
l.filter("checkerboard", clr1=color(0.35), width=8)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers44.jpg" width="150"/></span>
          </td><td>
            Applying a bloom filter:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("bloom")
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers55" height="150" src="../etc/lib/coreimage-layers55.jpg" width="150"/></span><br/>
          </td><td>
            Applying rectangular pixelation:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("pixelate", scale=7)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers56" height="150" src="../etc/lib/coreimage-layers56.jpg" width="150"/></span>
          </td><td>
            Applying polygonal pixelation:
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("crystallize", scale=15)
</pre>
        </td></tr><tr>
          <td><img alt="coreimage-layers63" height="150" src="../etc/lib/coreimage-layers63.jpg" width="150"/><br/>
          </td><td>
            Applying halftone effect:
<pre>
l = canvas.append("leaf.jpg")
l.filter("dotscreen")
l = canvas.append("coreimage-flower.png")
l.filter("dotscreen")
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers45.jpg" width="150"/></span>
          </td><td>
            Applying lighting:
<pre>
canvas.append(color(0))
l = canvas.append("lily.tif")
l.filter("lighting", dx1=-55, dy0=55, dz0=45)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers46.jpg" width="150"/></span>
          </td><td>
            Applying shading:
<pre>
canvas.append(color(0))
p = supershape.path(50, 60, 60, 60, 12, 2, 0.7, -2)
l = canvas.append(p, fill=color(1))
l.filter("shading", dx=31, radius=5.0)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers47.jpg" width="150"/></span>
          </td><td>
<pre>
canvas.append(color(0))
p = supershape.path(50, 60, 60, 60, 12, 2, 0.7, -2)
l = canvas.append(p, fill=color(1))
t = coreimage.canvas(150, 150)
t.append("lily.tif")
l.filter("shading", dx=31, radius=20.0, texture=t)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers64" height="150" src="../etc/lib/coreimage-layers64.jpg" width="150"/></span>
          </td><td>
            Applying line overay:
<pre>
canvas.append(color(0))
l = canvas.append("leaf.jpg")
l.filter("lineoverlay", noise=0.08, sharpness=0.1,
    threshold=0.3, contrast=2, intensity=1)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers54" height="150" src="../etc/lib/coreimage-layers54.jpg" width="150"/></span>
          </td><td>
             Applying a page curl transition:
<pre>
canvas.append(color(0))
l = canvas.append("leaf.jpg")
l.filter("pagecurl", time=0.55, angle=45, radius=60)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img height="150" src="../etc/lib/coreimage-layers48.jpg" width="150"/></span>
          </td><td>
            Applying color level adjustments:
<pre>
l = canvas.append("leaf.jpg")
l.filter("levels", g=0.6, b=1.6)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers60" height="150" src="../etc/lib/coreimage-layers60.jpg" width="150"/></span>
          </td><td>
            Using levels for a custom dropshadow (with zoomblur for exanple):
<pre>
canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.filter("levels", r=0, g=0, b=0)
l.filter("zoomblur", dx=-20, dy=40)
l.blend(75)
l.x += 10; l.y += 10
l = canvas.append("lily.tif")
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="coreimage-layers62" height="150" src="../etc/lib/coreimage-layers62.jpg" width="150"/></span><br/>
          </td><td>
            Finding edges:
<pre>
canvas.append(color(0))
l = canvas.append("lily.tif")
l.filter("edges", intensity=2.0)
</pre>
          </td></tr></tbody></table>

    <p> </p>
    <p><span class="grey_box">Filter aliases</span></p>
    <p>All the information about filters and their parameters is stored in the canvas renderer.
    Take a look at:</p>
<pre>print canvas.renderer.aliases.keys()
&gt;&gt;&gt; ['starshine', 'shading', 'bumpdistortion', 'zoomblur', 'motionblur',
&gt;&gt;&gt;  'levels', 'twirl', 'perspectivetile', 'lighting',
&gt;&gt;&gt;  'bloom', 'kaleidoscope']

print canvas.renderer.aliases["levels"]
&gt;&gt;&gt; CIColorMatrix

print canvas.renderer.filters["CIColorMatrix"]
&gt;&gt;&gt; {'a': 1.0, 'interface': False, 'r': 1.0, 'b': 1.0, 'g': 1.0}
</pre>

    <p> </p>
    <hr size="2" width="100%"/>

    <h2><a id="dropshadows" name="dropshadows" title="dropshadows"></a>Layer dropshadows</h2>

    <p>You can add a shadow to each layer in the canvas, in the same way as you can add a shadow to
    PlotDevice primitives with the <a href="Colors.html">Colors</a> library:</p>
<pre>layer.shadow(dx=10, dy=10, alpha=0.75, blur=8)
</pre>             

    <table>
      <tbody>
        <tr>
          <td><img alt="coreimage-layers61" height="150" src="../etc/lib/coreimage-layers61.jpg" width="150"/>
          </td><td>
            Default dropshadow:<br/>
<pre>
l = canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
l.shadow()
</pre>
          </td></tr></tbody></table>

    <p> </p>
    <hr/>

    <h2><a id="pixels" name="pixels" title="pixels"></a>Working with layer pixels</h2>

    <p>To create a canvas layer from a list of pixel colors, use <i>canvas.append()</i> as
    explained in the section on <a href="#adding_layers">adding layers</a>.</p>
    <p>You can access individual pixels in a layer or retrieve information about the minimum,
    maximum and average pixel values. The <i>layer.pixels()</i> gives you a pixels object that is a
    list of colors with some extra methods: <i>pixels.min()</i>, <i>pixels.max()</i>,
    <i>pixels.average()</i>, and <i>pixels.</i><i>get_pixel()</i>, <i>pixels.</i><i>set_pixel()</i>
    and <i>pixels.</i><i>get_range().</i> These return a <a href="../ref/Line+Color.html#color()">color</a>.</p>
<pre>l = canvas.append("leaf.jpg")
p = l.pixels()
</pre>
<pre>print p.is_rgb()
&gt;&gt;&gt; True
</pre>
<pre>print p.has_alpha()
&gt;&gt;&gt; False
</pre>
<pre>print "min:", p.min()
print "max:", p.max()
print "avg:", p.average()
&gt;&gt;&gt; min: color(0.02, 0.03, 0.00)
&gt;&gt;&gt; max: color(0.44, 0.54, 0.49)
&gt;&gt;&gt; avg: color(0.18, 0.31, 0.19)
</pre>
<pre>print p.get_pixel(100, 100)
&gt;&gt;&gt; color(0.09, 0.11, 0.03)
</pre>
<pre>print p.w, p.h
&gt;&gt;&gt; 150, 150
</pre>

    <p>There’s also a <i>pixels.</i><i>set_pixel()</i>. It takes an <i>x</i> and <i>y</i> position
    and a <i>color</i> as parameters. When you modify pixels in this way, changes will not
    automatically be committed to the layer. You need to <b>explicitly call</b>
    <i>pixels.</i><i>update()</i> on the pixels object when you’re done modifying. Also, remember
    that pixel operations can be time and memory intensive.<br/></p>
<pre>p = l.pixels()
p.set_pixel(100, 100, color(0,1,0))
p.update()
</pre>             

    <p>The <i>pixels.get_range()</i> method returns a list of colors. It takes <i>x</i> and
    <i>y</i> and <i>w</i> and <i>h</i> parameters. This way you can select a rectangular box of
    pixels from the layer.</p>
    <p>As a fun experiment we can transform the pixels to PlotDevice vector rectangles. We measure the
    RGB values in every tenth pixels and apply those colors to a grid of 10 x 10 rectangles:</p>
    <p> </p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-layers50.jpg" width="751"/></span></p>
    <p> </p>
    <p><span class="grey_box">Pixel histogram</span></p>
    <p>The <i>pixels.histogram()</i> extracts a histogram from the layer’s pixel data. The return
    value is a list with either three (R, G and B) or four (R, G, B, A) elements. Each element is a
    list of 254 elements ranging between 0.0 and 1.0. For example: if
    <i>pixels.histogram()[0][100]</i> would be 0.0, this means that the layer has no pixels where
    the red is 100. If <i>pixels.histogram()[1][10]</i> would be 1.0, this means that the layer’s
    pixels usually have a green value of 10.</p>
    <p>Let’s have a look at the pixel values of the leaf image using another one of the visual aids
    in the Core Image library:</p>
    <p> </p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-layers51.jpg" width="751"/></span></p>
    <p> </p>
    <hr/>

    <h2><a id="export_the_canvas" name="export_the_canvas" title="export_the_canvas"></a>Exporting
    the canvas to JPEG, GIF, PNG or TIFF</h2>

    <p>It’s easy to export the canvas as an compressed image for the web or a TIFF with CMYK
    colors. If your image has few different colors (e.g. opaque color planes with text) you can use
    export a lossless GIF for the web. If your image contains photos, use a JPEG with compression.
    When you are going to paper print your image, use a CMYK TIFF.</p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td><img height="150" src="../etc/lib/coreimage-flower.jpg" width="150"/>
          </td><td>
            A JPEG for the web with 40% compression:
<pre>
canvas = coreimage.canvas(150, 150)
l = canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
canvas.export("flower.jpg", compression=0.6)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-flower-tif.jpg" width="150"/>
          </td><td>
            A TIFF in CMYK with LZW-compression:
<pre>
canvas = coreimage.canvas(150, 150)
l = canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
canvas.export("flower.tif",
              cmyk=True, compression=True)
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-flower.png" width="150"/>
          </td><td>
            A PNG image with a transparent background:
<pre>
canvas = coreimage.canvas(150, 150)
l = canvas.append("lily.tif")
canvas.export("flower.png")
</pre>
        </td></tr><tr>
          <td><img height="150" src="../etc/lib/coreimage-flower.gif" width="150"/>
          </td><td>
            A GIF image file:
<pre>
canvas = coreimage.canvas(150, 150)
l = canvas.append(color(1.0, 0.0, 0.5))
font("Georgia-Italic", 40)
p = textpath("text", 0, 0)
l = canvas.append(p, fill=color(1))
canvas.export("flower.gif")
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>Some important things to know:</p>
    <ul>
      <li>
        <p>A generic CMYK profile is used. This means that the canvas renderer makes no attempt to
        correctly remap colors that are outside the CMYK scope: pure RGB red and other high
        intensity colors may contain pixel errors. This is especially true for layers created from
        paths. It is your responsibility to create paths in CMYK-safe colors. Usually everything is
        OK so long as you use paths created with PlotDevice <a href="../ref/Line+Color.html#color()">color()</a> colors.</p>
      </li><li>When you export Core Image compositions from the PlotDevice file menu, PDF export won’t work
      under Mac OS X 10.5. You can export JPEG, GIF and PNG however.<br/>
    </li></ul>

    <p> </p>
    <hr/>

    <h2><a id="drawing_the_canvas" name="drawing_the_canvas" title="drawing_the_canvas"></a>Drawing
    the canvas in PlotDevice</h2>

    <p>Merging all the layers in a canvas and drawing the result in PlotDevice is easy:</p>
<pre>canvas = coreimage.canvas(150, 150)
l = canvas.append("leaf.jpg")
l = canvas.append("lily.tif")
canvas.draw(0, 0)
</pre>

    <p>The <i>canvas.draw()</i> command takes two optional parameters: the x and y position.</p>
    <p>Note that when you export a PDF that contains a canvas with a transparent background it
    might have pixel errors.<br/>
    <br/></p>
    <hr/>

    <h2><a id="helpers" name="helpers" title="helpers"></a>Working with helpers and interfaces</h2>

    <p>Some things in the Core Image library are a little hard to do or grasp without visual
    feedback. That’s why the library has a few helpers and interfaces. There’s a helper for the
    <i>canvas.draw()</i> command that displays rulers and a bounding box for each of the layers.
    It’s already shown in the documentation on <a href="#transforming_layers">transforming
    layers</a>. There’s also a helper for the pixels histogram shown in the documentation on
    <a href="#pixels">working with pixels</a>.</p>
    <p>Furthermore, there’s a helper for the lighting filter. The helper makes it a bit easier to
    determine where the light source is positioned and what parameters like <i>dz0</i> and
    <i>concentration</i> do.</p>
    <p> </p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-layers52.jpg" width="751"/></span></p>
    <p>With each filter you can use the <i>interface</i> parameter to get PlotDevice sliders that
    control the options for the filter. It’s a convenient way to get to know how each filter works.</p>
    <p><span class="media"><img height="551" src="../etc/lib/coreimage-layers53.jpg" width="739"/></span></p>
    <p> </p>
    <p>Notice how each parameter you normally define in code is now replaced by a handy slider.</p>
    <p> </p>
    <hr/>

    <h2><a id="morguefile" name="morguefile" title="morguefile"></a>Working with images from
    MorgueFile</h2>

    <p>The Core Image library includes a tool to download images from <a href="http://www.morguefile.com/">MorgueFile</a>. MorgueFile is an online archive of freely
    contributed photographs. To use MorgueFile images in PlotDevice, you need to add the
    <i>morguefile.py</i> library to the folder where your script is located. You can then query
    MorgueFile and download images to a specified folder.</p>
    <p> </p>
    <p><span class="media"><img height="520" src="../etc/lib/coreimage-morguefile1.jpg" width="751"/></span></p>
    <p>The <i>morguefile.search()</i> command returns a list of images on MorgueFile on the given
    query, It has an optional parameter <i>max</i> specifying the maximum number of images to
    return.</p>
<pre>from coreimage import morguefile
images = morguefile.search("leaf", max=10)
</pre>

    <p>Each item in the returned list has a number of properties:</p>
    <ul>
      <li><i>img</i>.id: the unique MorgueFile ID for the image
      </li><li><i>img</i>.category: the category the image belongs to
      </li><li><i>img</i>.author: the name of the author
      </li><li><i>img</i>.name: the image’s name
      </li><li><i>img</i>.url: the URL of the image thumbnail
      </li><li><i>img</i>.date: the date the image was added to MorgueFile
      </li><li><i>img</i>.views: the number of times the image has been viewed
      </li><li><i>img</i>.downloads: the number of times the image has been downloaded
    </li></ul>
<pre>for img in images:
    print img.name, img.views
&gt;&gt;&gt; DSCN6707.JPG 8
&gt;&gt;&gt; keegan_2006_1015random0106.JPG 10
&gt;&gt;&gt; Img2006-10-08-132310.jpg 611
&gt;&gt;&gt; climb_a_tree_2006_1015random0086.JPG 17
&gt;&gt;&gt; missyredboots111.jpg 14
&gt;&gt;&gt; IMG_6852.jpg 403
&gt;&gt;&gt; Fallen_Star.JPG 25
&gt;&gt;&gt; JGS_mF_FloatingInDarkness.jpg 30
&gt;&gt;&gt; leaf_n.JPG 18
&gt;&gt;&gt; drift_away__.jpg 103
</pre>

    <p>You can use the <i>img.download()</i> method with any of these image objects. This command
    takes two optional parameters: <i>path</i> specifying in what folder to put the image (if the
    folder doesn’t exist it will be created) and <i>thumbnail</i>, which when True downloads a
    small thumbnail instead of the image itself.</p>
    <p>The command returns the pathname of the image, which is the specified <i>path</i> + the name
    of the author + the name of the image.</p>
<pre>print images[0].download("images")
&gt;&gt;&gt; images/dineshtilva_DSCN6707.JPG
</pre>

    <p> </p>
    <p><span class="media"><img height="411" src="../etc/lib/coreimage-morguefile2.jpg" width="548"/></span></p>
    <p>You can then start using the image as a canvas layer.</p>
    <p>There’s also the <i>morguefile.search_by_author()</i> command which looks for images by
    author name.</p>
    <p> </p>
    <hr/>

    <h2><a id="dynamics" name="dynamics" title="dynamics"></a> Working with dynamics and
    caching</h2>

    <p>You can create a cached screenshot from a layer or a canvas. This means Core Image will
    render the layer or canvas with all its transformations, masks, adjustments and filters and
    return it as an object stored in memory instead of drawing it to the screen. You can then reuse
    that object as a layer in a canvas. This way you can incrementally <i>stack</i> effects in a
    fast animation.</p>
    <p>The <i>layer.render()</i> and <i>canvas.flatten()</i> methods return a cached screenshot.
    You can pass this screenshot to the <i>canvas.append()</i> command. Then you can stack new
    effects on the transformed layer, take a screenshot of it, apply more filters to it, and so
    on.<br/></p>
    <p> 
    <table border="0">
      <tbody>
        <tr>
          <td>
            <p><span class="image_border"><img alt="coreimage-dynamics1" height="149" src="../etc/lib/coreimage-dynamics1.jpg" width="149"/></span><br/>
            <span class="image_border"><img alt="coreimage-dynamics2" height="149" src="../etc/lib/coreimage-dynamics2.jpg" width="149"/></span><br/></p>
          </td><td>
<pre>
speed(30)
def setup():
    global cache
    cache = None

def draw():
    canvas = coreimage.canvas(WIDTH, HEIGHT)
    global cache
    if not cache:
        cache = canvas.append("leaf.jpg")
    else:
        cache = cache.render()
        cache = canvas.append(cache)
        cache.filter("twirl",
                     radius=random(30,40),
                     dx=random(-40,40),
                     dy=random(-40,40))

    canvas.draw()
</pre>
          </td></tr></tbody></table></p>
    <p>Try out some other examples bundled in the library download. You may notice that
    incrementally applying filters and effects to layers makes them blurry.</p>
    <p> </p>
    <hr/>

    <h2><a id="issues" name="issues" title="issues"></a>Known issues and limitations</h2>

    <p>The library is currently in alpha stage and has some known issues and limitations:</p>
    <ul>
      <li>
        <p>Exporting a PDF with a canvas that has a transparent background might contain pixel
        errors.</p>
      </li><li>
        <p>Exporting a CMYK TIFF uses a Generic CMYK profile. This means that the canvas renderer
        makes no attempt to correctly remap colors that are outside the CMYK scope: pure RGB red
        and other high intensity colors may contain pixel errors. This is especially true for
        layers created from paths. It is your responsibility to create paths in CMYK-safe colors.
        Usually everything is OK so long as you use paths created with PlotDevice <a href="../ref/Line+Color.html#color()">color()</a> colors.</p>
      </li><li>
        <p>Using the <i>layer.distort()</i> command in combination with layer filters displaces the
        layer from the origin, because the bounding box of a layer does not take filters into
        account. This means that the layer will no longer correctly display at the position you
        specified. An easy way to overcome this is to call <i>layer.filters_first(False)</i> to
        first render the distort and then apply the filter.</p>
      </li><li>
        <p>Combining different filters might sometimes produce no output or crash PlotDevice. If you
        are experiencing strange behaviour, try quitting and reopening PlotDevice so the Core Image
        library has a chance to reload itself.</p>
      </li><li>
        <p>Some filters are kinda quirky, especially the motion blur filter and perspective tile.</p>
      </li><li>
        <p>If you rotate a canvas drawn in PlotDevice using <i>transform(CORNER)</i> it rotates from
        the bottom left corner instead of the top left corner.</p>
      </li><li>Core Image might run very slow or even halt PlotDevice when exporting multiple PDF’s or
      animations from a complex canvas. Exporting image files leaks memory as well (which can
      result in kernel panic). I haven’t found a solution yet - there’s a problem when calling
      <i>CIContext().drawImage</i>. For now, don’t export movies/PDF’s/images in batch (e.g. a
      thousand in one roll), or use an external screen capture tool like IShowU.<br/>
    </li></ul>

    <p> </p>
  </div>

</body></html>