<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>

  <title></title>

</head><body>
  <div class="article">
    <p>The PlotDevice Colors library offers a set of tools to work with color more conveniently. You
    can use the library to create colors by name (like <i>red</i> or <i>ivory</i>), from pixels in
    an image, group them into lists of which you can then collectively manipulate hue, brightness
    and saturation, create lists of harmonious colors based on color theory rules (like
    complementary or analogous), create lists of gradient colors, work with drop shadows and
    gradient fills for paths, define powerful <i>indefinite</i> color ranges (like <i>bright
    red</i> or <i>purplishgreenish</i>), aggregate color information from Yahoo!, and more!<br/></p>
    <p>There’s a lot of stuff to explain but luckily most principles in the Colors library are
    easy.<br/>
    Some central themes are:</p>
    <ul>
      <li><b>Colors:</b> enhanced color objects with many predefined instances.
      </li><li><b>Color lists:</b> sets of colors which can be manipulated as a whole.
      </li><li><b>Rules:</b> color theory rules that generate lists of colors.<br/>
      </li><li><b>Color ranges:</b> variable sets of colors whose HSB values are constrained between a
      minimum and a maximum value.
      </li><li><b>Color themes:</b> groups of ranges.
      </li><li><b>Depth:</b> lighting, shadows and gradients.<br/>
    </li></ul>

    <p>My personal favorites are <a href="#shade">shades</a> and <a href="#shadow">shadows and
    gradient fills</a>.</p>
    <p class="pink_text">If you have PlotDevice 1.10 or up, the library is integrated by default as
    the <a href="../ref/Globals.html#colors">colors</a> object.</p>
    <h2>Previous Version Download</h2>

    <table border="0">
      <tbody>
        <tr>
          <td><a href="http://nodebox.net/code/data/media/colors.zip"><img alt="download" height="20" src="../etc/lib/download.gif" width="20"/></a>
          </td><td><a href="http://nodebox.net/code/data/media/colors.zip">colors.zip</a> (1.95MB)<br/>
          <i>Last updated for PlotDevice 1.9.4.9<br/>
          Licensed under GPL<br/></i><i>Authors: Tom De Smedt, Frederik De Bleser</i><br/>
        </td></tr></tbody></table>

    <h2>Documentation</h2>

    <ul>
      <li><a href="#color">Colors</a>
      </li><li><a href="#colorlist">Color lists</a>
      </li><li><a href="#rules">Color lists from harmony rules</a> (complementary, analogous, ...)
      </li><li><a href="#gradient">Color lists from gradients</a>
      </li><li><a href="#range">Color ranges</a>
      </li><li><a href="#shade">Predefines color ranges: shades</a> (dark, bright, cool, ...)
      </li><li><a href="#theme">Grouping ranges into themes</a>
      </li><li><a href="#web">Aggregating colors from the web</a>
      </li><li><a href="#shader">Using a shader for lighting effects</a>
      </li><li><a href="#shadow">Using dropshadows and gradient fills</a><br/>
    </li></ul>

    <p> </p>
    <hr/>

    <h2><a id="color" name="color" title="color"></a>Colors</h2>

    <p>The Colors library has a number of commands that create a new color you can use with
    <a href="../ref/Line+Color.html#fill()">fill()</a> or <a href="../ref/Line+Color.html#fill()">stroke()</a>.</p>
<pre>rgb(r, g, b, a=None, range=1.0, name="")
</pre>
<pre>hsb(h, s, b, a=None, range=1.0, name="")
</pre>
<pre>cmyk(c, m, y, k, range=1.0, name="")
</pre>
<pre>lab(l, a, b, range=1.0, name="")
</pre>
<pre>hex(str, name="")
</pre>

    <p>With the <i>range</i> parameter you can define how you want to supply the channel values.
    For example, if you want to define <i>r</i>, <i>g</i> and <i>b</i> between 0 and 255 instead of
    between 0.0 and 1.0, set <i>range</i> to 255.</p>
    <p>The optional <i>name</i> parameter lets you define a name for the color. Otherwise, a name
    will be guessed using the <i>clr.nearest_hue()</i> method (see below).</p>
    <p>The <i>hex()</i> command creates a color from a hexadecimal string (e.g. ‘#30343D’).<br/></p>
<pre>named_color(str)
</pre>

    <p>The <i>named_color()</i> command creates a color from a name like ‘olive’ or ‘maroon’ or
    ‘antiquewhite’. A list of all the named colors the command will recognize is <a href="Colors/named_colors.html">here</a>. The really great thing is that <b>each of these named
    colors is also a command</b> in the Colors library. So the two colors in the example below are
    exactly the same:</p>
<pre>clr1 = colors.named_color("olive")
clr2 = colors.olive()
</pre>

    <p> </p>
    <hr/>

    <p><span class="grey_box">Color properties</span></p>
    <p>Each of the above commands returns a <i>Color</i> object. It has all the standard properties
    a color created with the PlotDevice <a href="../ref/Line+Color.html#color()">color()</a> command
    also has. You can use these to find out the color’s R, B and B values, or its C, M, Y and K
    values, or its H, S and B values:</p>
    <ul>
      <li><i>clr.r</i>: the red value in RGB.
      </li><li><i>clr</i><i>.g</i>: the green value in RGB.
      </li><li><i>clr</i><i>.b</i>: the blue value in RGB.
      </li><li><i>clr</i><i>.a</i>: the alpha value (opacity).
      </li><li><i>clr</i><i>.c</i>: the cyan value in CMYK.
      </li><li><i>clr</i><i>.m</i>: the magenta value in CMYK.
      </li><li><i>clr</i><i>.y</i>: the yellow value in CMYK.
      </li><li><i>clr</i><i>.k</i>: the black value in CMYK.
      </li><li><i>clr</i><i>.hue</i>: the hue of the color in HSB.
      </li><li><i>clr</i><i>.saturation</i>: the saturation (grayness) of the color in HSB.
      </li><li><i>clr</i><i>.brightness</i>: the brightness of the color in HSB.
    </li></ul>

    <p>The <i>Color</i> object in the Colors Library has some additional properties:</p>
    <ul>
      <li><i>clr</i><i>.name</i>: the name of this color.<br/>
      </li><li><i>clr</i><i>.is_black</i>: will be <i>True</i> when the color’s R, G and B values are 0.
      </li><li><i>clr</i><i>.is_white</i>: will be <i>True</i> when the color’s R, G and B values are 1.
      </li><li><i>clr</i><i>.is_gray</i>: will be <i>True</i> when the color’s R, G and B values are the
      same.
      </li><li><i>clr</i><i>.is_transparent</i>: will be <i>True</i> when the color is completely
      transparent.<br/>
      </li><li><i>clr</i><i>.complement</i>: the complementary color (i.e. 180 degrees across the color
      wheel) of this color.<br/>
    </li></ul>

    <p> </p>
    <hr/>

    <p><span class="grey_box">Color methods</span></p>
    <p>Each color has a range of methods to manipulate it. Each of these returns a <b>copy</b> of
    the color.</p>
<pre>clr.copy()
</pre>
<pre>clr.darken(step=0.1)
</pre>
<pre>clr.lighten(step=0.1)
</pre>
<pre>clr.desaturate(step=0.1)
</pre>
<pre>clr.saturate(step=0.1)
</pre>
<pre>clr.adjust_contrast(step=0.1)
</pre>
<pre>clr.adjust_rgb(r=0.0, g=0.0, b=0.0, a=0.0)
</pre>
<pre>clr.adjust_hsb(h=0.0, s=0.0, b=0.0, a=0.0)
</pre>

    <p>What is interesting about these methods is that you can also apply them to <a href="#colorlist">color lists</a>. This way you can quickly manipulate sets of colors without having
    to change each color individually.</p>
    <p>The <i>clr.blend()</i> command returns a mixture from this color and another color:</p>
<pre>clr.blend(clr, factor=0.5)
</pre>

    <p>The <i>clr.rotate()</i> command returns a color that is <i>angle</i> degrees across the
    color wheel. So when <i>angle</i> is 180, this returns the complementary color.</p>
<pre>clr.rotate(angle=180)
</pre>

    <p>The <i>clr.analog()</i> command returns hues that are next to this one on the color wheel,
    separated by <i>angle</i>. The additional <i>d</i> parameter will slightly vary the color’s
    brightness and saturation for more variation.<br/></p>
<pre>clr.analog(angle=20, d=0.5)
</pre>

    <p>Another interesting method is <i>clr.nearest_hue()</i>. This returns the name of the name of
    a well-known hue this color resembles most (<i>red, orange, yellow, lime, green, teal, cyan,
    azure, blue, violet, purple or pink</i>). When the <i>primary</i> parameter is <i>True</i>, the
    name returned is limited to primary hues: <i>red, orange, yellow, green, blue, purple,
    pink</i>.</p>
<pre>clr.nearest_hue(primary=False)
</pre>

    <p>To get the distance between two colors as a number there’s the <i>clr.distance()</i> method.
    It returns a number between 0.0 and 1.0 representing the distance as if colors were arranged on
    a sphere (e.g. a disc of hues with the less saturated colors in the centre, darker discs in the
    sphere are at the bottom).</p>
<pre>clr.distance(clr)
</pre>

    <p>The <i>clr.swatch()</i> command draws a rectangle to the canvas filled with the color. The
    rectangle is located at <i>x</i> and <i>y</i> and has width <i>w</i> and height <i>h</i>.</p>
<pre>clr.swatch(x, y, w=35, h=35, roundness=0)
</pre>    

    <p> </p>
    <hr/>

    <h2><a id="colorlist" name="colorlist" title="colorlist"></a>Color lists</h2>

    <p>The functionality of the Colors library becomes more interesting when we get down to working
    with lists of colors. You can store different colors in a list and then manipulate the entire
    collection. For example, make all of the colors darker, retrieve the lightest color, or even
    create a list from pixels in an image for example.</p>
<pre>list(clr1, clr2, clr3, ..., name="", tags=[])
</pre>
<pre>list([clr1, clr2, clr3, ...], name="", tags=[])
</pre>
<pre>list(imagepath, n=10)
</pre>
<pre>list(word)
</pre>
<pre>list(Web.KulerTheme)
</pre>

    <p>Lists can be created from a number of indivdual colors, another list of colors, the pathname
    of an image from which to grab pixel values (you need to have the <a href="Core_Image.html">Core Image</a> library installed), a word, or a kuler theme from the <a href="Web.html#kuler">web.kuler.search()</a> command in the PlotDevice Web library.</p>
    <p>Optionally you can supply a <i>name</i> and a list of <i>tags</i> for the list.</p>
    <p>Accessing each individual color in the list works the same as with any other list:</p>
<pre>sea = colors.list("sea.jpg", n=20)
x = 0
for clr in sea:
    rect(x, 0, 20, 20, fill=clr)
    x += 20
</pre>

    <p><img alt="colors_colorlist1" height="27" src="../etc/lib/colors_colorlist1.jpg" width="550"/></p>
    <p>You can also use the <a href="../ref/Utility.html#choice()">choice()</a> command to get a
    random colors from the list.</p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Color list properties</span></p>
    <p>Each of the above commands returns a <i>ColorList</i> object with a number of properties:</p>
    <ul>
      <li><i>list.name</i>: the name of the set of colors.
      </li><li><i>list</i><i>.tags</i>: a list of associations.
      </li><li><i>list</i><i>.darkest</i>: the darkest color in the list (useful as a background or a
      text color for example).
      </li><li><i>list</i><i>.lightest</i>: the lightest color in the list.
      </li><li><i>list</i><i>.average</i>: the average (mean) color of all the colors in the list.
      </li><li><i>list</i><i>.complement</i>: the complementary color list.<br/>
    </li></ul>

    <p> </p>
    <hr/>

    <p><span class="grey_box">Color list methods</span><br/></p>
    <p>Some methods to manipulate the list. All of these will return a <b>copy</b> of the list.<br/></p>
<pre>list.reverse()
</pre>
<pre>list.sort(reversed=True)
</pre>
<pre>list.repeat(self, n=2, oscillate=False, callback=None)
</pre>

    <p>The <i>list.reverse()</i> method returns a copy with all the colors in reversed order.</p>
    <p>The <i>list</i><i>.sort()</i> method returns a copy with the colors sorted from dark to
    light.</p>
    <p>The <i>list</i><i>.repeat()</i> method returns a repetition of the list: if the list
    contains a <i>red</i>, <i>green</i> and a <i>yellow</i> color, <i>list</i><i>.repeat()</i> will
    contain <i>red, green, yellow, red, green, yellow</i>. When <i>oscillate</i> is <i>True</i> it
    will contain <i>red, green, yellow, yellow, green, red</i>. This is useful for lists of
    gradient colors.</p>
<pre>list.swarm(x, y, r=100)
</pre>

    <p>The <i>list.swarm()</i> method draws a small visualization of all the colors in the list.
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors_colorlist2" height="101" src="../etc/lib/colors_colorlist2.jpg" width="100"/></span>
          </td><td>
<pre>
sea = colors.list("sea.jpg", n=20)
background(sea.darkest)
sea.swarm(50, 50)
</pre>
          </td></tr></tbody></table></p>
    <p>All of the methods that work on a single color also work on a list of colors. They will
    transform all the individual colors in the list:</p>
<pre>list.copy()
</pre>
<pre>list.darken(step=0.1)
</pre>
<pre>list.lighten(step=0.1)
</pre>
<pre>list.desaturate(step=0.1)
</pre>
<pre>list.saturate(step=0.1)
</pre>
<pre>list.adjust_contrast(step=0.1)
</pre>
<pre>list.adjust_rgb(r=0.0, g=0.0, b=0.0, a=0.0)
</pre>
<pre>list.adjust_hsb(h=0.0, s=0.0, b=0.0, a=0.0)
</pre>
<pre>list.analog(self, angle=20, d=0.5)
</pre>
<pre>list.rotate(self, angle=180)
</pre>
<pre>list.swatch(x, y, w=35, h=35, padding=0, roundness=0)
</pre>

    <p> </p>
    <hr size="2" width="100%"/>

    <p><span class="grey_box">Color list sorting</span></p>
    <p>The colors in a list can be sorted in various ways:</p>
<pre>list.sort(comparison="hue", reversed=False)
</pre>
<pre>list.sort_by_distance(reversed=False)
</pre>
<pre>list.cluster(cmp1="hue", cmp2="brightness", reversed=False, n=12)
</pre>

    <p>The basic <i>list.sort()</i> method allows you to sort by any color property (hue,
    brightness, red, magenta, ...)</p>
    <p>The <i>list.cluster()</i> method sorts the list by the first given property, then cuts it
    into <i>n</i> pieces and sorts each of the pieces by the second given property.</p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Color list math</span><br/></p>
    <p>Individual colors (or lists of colors) can be added to a list with the + operator:
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors_colorlist3" height="100" src="../etc/lib/colors_colorlist3.jpg" width="100"/></span>
          </td><td>
<pre>
clrs = colors.list(
    colors.purple().darken(), 
    colors.deeppink() 
)
clrs += colors.violet()
clrs.swarm(50, 50)
</pre>
          </td></tr></tbody></table></p>
    <p>Also, the * operator is equivalent to the <i>list.repeat()</i> method.<br/></p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Color context</span><br/></p>
    <p>There’s one additional <i>list.context</i> property which is a list of words associated with
    the colors in the list. For example, red is commonly associated with things like anger and
    passion, while black is associated with death, grief, modernism.</p>
    <p>If you put them together in a color list, its context will contain words like anger, drama
    and power.
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors_colorlist4" height="100" src="../etc/lib/colors_colorlist4.jpg" width="100"/></span>
          </td><td>
<pre>
clrs = colors.list( colors.red(), colors.black() )
clrs.swarm(50, 50)
print clrs.context
&gt;&gt;&gt; ['anger', 'devil', 'drama', 'power', 'sex', 'strength']
</pre>
          </td></tr></tbody></table></p>
    <p>The data is drawn from the files in the <i>/context</i> subfolder in the library. You can
    adjust them to your own needs. There’s also a dictionary with all the information:</p>
<pre>print colors.context["red"]
</pre>    
    <hr/>

    <h2><a id="rules" name="rules" title="rules"></a>Color lists from harmony rules</h2>

    <p>Color theory provides a visual guidance to color mixing and the visual impact of specific
    color combinations. With the Colors library you can create schemes from the following rules:</p>
    <ul>
      <li><b>complementary:</b> colors that are opposite of each other on the color wheel.
      </li><li><b>split complement:</b> a combination of left complement and right complement.
      </li><li><b>left complement:</b> a variation with colors a bit to the left of the actual
      complement.
      </li><li><b>right complement:</b> a variation with colors a bit to the right of the actual
      complement.
      </li><li><b>analogous:</b> colors that are next to each other on the color wheel. These yield
      natural schemes, like shades of water or grass).
      </li><li><b>monochrome:</b> colors in the same hue that vary in brightness and saturation.
      </li><li><b>triad:</b> a color and two other colors that make up an equilateral triangle on the
      color wheel.
      </li><li><b>tetrad:</b> four colors that make up a cross on the color wheel.
      </li><li><b>compound:</b> a color with its complement and some analogs of those colors.
    </li></ul>

    <p> </p>
<pre>complement(clr)
</pre>
<pre>complementary(clr)
</pre>
<pre>split_complementary(clr)
</pre>
<pre>left_complement(clr)
</pre>
<pre>right_complement(clr)
</pre>
<pre>analogous(clr, angle=10, contrast=0.25)
</pre>
<pre>monochrome(clr)
</pre>
<pre>triad(clr, angle=120)
</pre>
<pre>tetrad(clr, angle=90)
</pre>
<pre>compound(clr, flip=False)
</pre>

    <p>All of the commands take a base <i>clr</i> from which a scheme is then derived. A <a href="#colorlist">color list</a> is returned, usually containing three to six matching colors
    (except <i>complement()</i>, which just returns the original color and its complement). Notice
    that some commands have an <i>angle</i> parameter. This controls how far colors are apart on
    the color wheel. Making it bigger for the <i>analogous()</i> scheme introduces more variation.</p>
    <p>There’s also a <i>rule()</i> command where you can supply the rule name as a string. All of
    the rule names are stored in the <i>rules</i> list.<br/></p>
<pre>rule(name, clr, angle=None, contrast=0.3, flip=False)
</pre>
<pre>print colors.rules
&gt;&gt;&gt; ['complement', 'complementary', 'split complementary', 'left complement', 
&gt;&gt;&gt;  'right complement', 'analogous', 'monochrome', 'triad', 'tetrad', 
&gt;&gt;&gt;  'compound', 'flipped compound']
</pre>

    <p>With the <i>rule()</i> command we can quickly display all the possibilities for a color:</p>
<pre>clr = colors.rgb(0.0, 0.4, 0.6)
x = 10
for name in colors.rules:
    scheme = colors.rule(name, clr)
    scheme.swatch(x, 10)
    x += 40
</pre>

    <p><img alt="colors-rules0" height="230" src="../etc/lib/colors-rules0.jpg" width="460"/></p>
    <p> </p>
    <hr/>

    <p>Here are some individual schemes:<br/>
    <table border="0">
      <tbody>
        <tr>
          <td class="image_border"><img alt="colors-rules1" height="150" src="../etc/lib/colors-rules1.jpg" width="150"/><br/>
          <br/>
          </td><td>
            <p>Complementary scheme:</p>
<pre>
clr = colors.rgb(0, 0.4, 0.6)
scheme = colors.complementary(clr)
scheme.swarm(75, 75)
scheme.swatch(0, 0, w=25, h=25)
</pre>
        </td></tr><tr>
          <td class="image_border"><img alt="colors-rules3" height="150" src="../etc/lib/colors-rules3.jpg" width="150"/><br/>
          <br/>
          </td><td>
            <p>Left complementary:</p>
<pre>
clr = colors.rgb(0, 0.4, 0.6)
scheme = colors.left_complement(clr)
scheme.swarm(75, 75)
scheme.swatch(0, 0, w=25, h=25)
</pre>
        </td></tr><tr>
          <td class="image_border"><img alt="colors-rules5" height="150" src="../etc/lib/colors-rules5.jpg" width="150"/><br/>
          <br/>
          </td><td>
            <p>Analogous:</p>
<pre>
clr = colors.rgb(0, 0.4, 0.6)
scheme = colors.analogous(clr)
scheme.swarm(75, 75)
scheme.swatch(0, 0, w=25, h=25)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="colors-rules10" height="150" src="../etc/lib/colors-rules10.jpg" width="150"/></span><br/>
          </td><td>
            <p>Flipped compound:</p>
<pre>
clr = colors.rgb(0, 0.4, 0.6)
scheme = colors.compound(clr, flip=True)
scheme.swarm(75, 75)
scheme.swatch(0, 0, w=25, h=25)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>Techies may want to note that calculations for the rules are performed on an <i>artistic
    color wheel</i> based on <a href="http://en.wikipedia.org/wiki/RYB_color_model">RYB</a> instead
    of RGB. This system predates scientific color theory and is mathematically incorrect - but it
    does produce better color schemes.</p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Analog color scheme</span><br/></p>
    <p>When you want a <b>realistic, organic feel</b> to your composition you can work with
    <b>analogous</b> schemes. Remember how a <a href="#color">color</a> object in the Colors
    library has an <i>analog()</i> method? It’s very easy to use in a loop so that each element is
    subtly different:</p>
<pre>size(600, 600)
nofill()
stroke(0.4, 0.5, 0)
strokewidth(0.1)
autoclosepath(False)
 
clr = colors.rgb(0.6, 0.4, 0, 0.5)
 
background(colors.dark(clr).darken(0.1))
colors.shadow(alpha=0.05, blur=0.2)
 
for i in range(50):
    
    # Each strand of curves has an analogous color
    # (i.e. hues that are next to each other on the color wheel).
    # This yields a very natural effect.
    stroke(clr.analog(angle=10, d=0.3))
 
    x0 = WIDTH/2
    y0 = HEIGHT/2
    vx0 = random(-200, 200)
    vy0 = random(-200, 200)
    vx1 = random(-200, 200) 
    vy1 = random(-200, 200)
    x1 = choice((-10, WIDTH))
    y1 = random(HEIGHT)
    for j in range(100):
        beginpath(x0, y0)
        curveto(
            x0+vx0+random(80), y0+vy0+random(80), 
            x1+vx1, y1+vy1, 
            x1, y1
        )
        endpath()
</pre>

    <p><img alt="colors-rules11" height="550" src="../etc/lib/colors-rules11.jpg" width="550"/><br/></p>
    <p>You can find this script fully documented in the library download.</p>
    <p> </p>
    <hr/>

    <h2><a id="gradient" name="gradient" title="gradient"></a>Color lists from gradients</h2>

    <p>The Colors library has a handy <i>gradient()</i> command that takes a couple of colors and
    calculates all the intermediary steps between them.</p>
<pre>gradient([clr1, clr2, clr3, ...], steps=100, spread=0.5)
</pre>
<pre>gradient(clr1, clr2, clr3, ..., steps=100, spread=0.5)
</pre>

    <p>You can supply base colors either as a list or simply as an enumeration of parameters. A
    <a href="#colorlist">color list</a> is returned with additional colors that form a smooth
    transistion between the given base colors. The command has two optional parameters:
    <i>steps</i> which defines the number of colors in the returned list, and <i>spread</i>, which
    defines the midpoint of the gradient.</p>
    <p>For example, here we create a gradient list from light blue to dark blue. For each color in
    the list an oval is drawn that zooms inward. So we draw 60 ovals that go from light blue to
    dark blue:<br/></p>
<pre>clr1 = colors.rgb(0.6, 0.8, 1.0)
clr2 = colors.rgb(0.0, 0.2, 0.4)
g = colors.gradient(clr1, clr2, steps=60)
 
for i in range(len(g)):
    fill(g[i])
    r = 700-i*10
    oval(-75+i*5, -180+i*5, r, r)
</pre>

    <p><span class="image_border"><img alt="colors-gradientlist1" height="330" src="../etc/lib/colors-gradientlist1.jpg" width="550"/></span></p>
    <p>Let’s add a nice spiral to the composition. As you can see in the example below, I can reset
    the number of <i>steps</i> in the gradient list (the number of colors is updated accordingly) -
    I don’t need to create a new gradient. The same goes for the gradient <i>spread</i>.
    Additionaly, remember that <i>g</i> is a color list so I can use the <i>reverse()</i> method:</p>
<pre># append this to the previous code:
 
g.steps = 200
g = g.reverse()
 
colors.shadow(blur=12, alpha=0.3)
transform(CORNER)
translate(WIDTH/2, HEIGHT/2)
for i in range(len(g)):
    fill(g[i])
    rotate(3)
    oval(i*0.5, i*0.5, 200-i, 200-i)
</pre>

    <p><span class="image_border"><img alt="colors-gradientlist2" height="330" src="../etc/lib/colors-gradientlist2.jpg" width="550"/></span></p>
    <p>My personal favorite is the one with all the different hues of blue mixed up. It reminds me
    of Alice in Wonderland. Replace the above <i>fill()</i> command with:</p>
<pre>fill(choice(g))
</pre>

    <p><img alt="colors-gradientlist3" height="330" src="../etc/lib/colors-gradientlist3.jpg" width="550"/><br/></p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Gradient outlines</span></p>
    <p>Finally, the Colors library has an <i>outline()</i> command which works extremely well with
    <i>gradient()</i>. The command colorizes the stroke of a path with the colors in a given list:</p>
<pre>outline(path, colors, precision=0.4, continuous=True)
</pre>

    <p>Outlines a <i>path</i> with the colors in the list. When <i>continuous</i> is False, each
    contour in the path starts with the first color in the list, and ends with the last color in
    the list. Because each line segment is drawn separately, the command works only with a
    corner-mode <a href="../ref/Transform.html#transform()">transform()</a>.</p>
<pre>font("Georgia", 58)
p = textpath("gradient text is back!", 10, 50)
g = colors.gradient(color(1,0,0.5), color(0,0.5,1))
 
colors.outline(p, g)
</pre>

    <p><img alt="colors-gradientlist4" height="80" src="../etc/lib/colors-gradientlist4.jpg" width="550"/></p>
    <p> </p>
    <hr/>

    <h2><a id="range" name="range" title="range"></a>Color ranges</h2>

    <p>A color range is a set of indefinite <b>colors that have their hue, saturation and
    brightness constrained</b> between a minimum and maximum value. You can use color ranges to
    quickly describe fuzzy concepts like <i>dark</i> and <i>bright</i>.</p>
<pre>range(h=(0.0,1.0), s=(0.0,1.0), b=(0.0,1.0), a=(1.0,1.0), 
      grayscale=False, name="", length=100)
</pre>

    <p>The <i>h</i>, <i>s</i>, <i>b</i> and <i>a</i> parameters are (min, max) tuples with
    <i>min</i> and <i>max</i> ranging between 0.0 and 1.0. A color range behaves like a list of
    <i>length</i> individual colors - although the colors will be <b>different</b> each time you
    draw them from the range.</p>
    <p>For example, the following range contains colors with all sorts of saturation and
    brightness, but their hues are limited between red and limegreen:
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors-colorrange1" height="100" src="../etc/lib/colors-colorrange1.jpg" width="100"/></span>
          </td><td>
<pre>
r = colors.range(h=(0,0.2))
r.swarm(50, 50)
print r[0:2]
&gt;&gt;&gt; [Color(0.287, 0.276, 0.252, 1.000), 
     Color(0.089, 0.064, 0.026, 1.000)]
</pre>
          </td></tr></tbody></table></p>
    <p>Color ranges often yield surprising results with a minimum amount of code:</p>
<pre>r = colors.range(h=(0,0.2))
transform(CORNER)
rotate(45)
for i in range(HEIGHT/10):
    fill(choice(r))
    rect(-WIDTH, i*15, WIDTH*2, 20)
</pre>

    <p><span class="image_border"><img alt="colors-colorrange2" height="550" src="../etc/lib/colors-colorrange2.jpg" width="550"/></span></p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Color range methods, properties and calls</span></p>
    <p>A color range has the following methods:</p>
<pre>range.constrain_hue(min, max=None)
</pre>
<pre>range.constrain_saturation(min, max=None)
</pre>
<pre>range.constrain_brightness(min, max=None)
</pre>
<pre>range.constrain_alpha(min, max=None)
</pre>

    <p>More complex ranges including gaps can be created by assigning a list of (<i>min</i>,
    <i>max</i>) tuples to a property directly:</p>
<pre>high_contrast_reds = colors.range()
high_contrast_reds.h = 0
high_contrast_reds.s = (0.5, 1.0)
high_contrast_reds.b = [(0.1,0.2), (0.9,1.0)]
</pre>

    <p>Since a color range behaves like a <a href="#colorlist">color list</a> it also has
    <i>copy()</i>, <i>adjust_rgb()</i>, <i>repeat()</i>, <i>swatch()</i> ... methods.</p>
    <p>If you need a single color from the range you can use the <i>range.color()</i> method:</p>
<pre>range.color(clr=None, d=0.035)
</pre>
<pre>range.colors(clr=None, n=10, d=0.035)
</pre>

    <p>However, you can also directly <b>call</b> a range like a command:</p>
<pre>yellowgreenish = colors.range(h=(0.1,0.2))
background( yellowgreenish() )
</pre>

    <p>When you call a color range like this you can supply three optional parameters:</p>
    <ul>
      <li><i>clr</i>: a color to which hue is used to constrain anything drawn from the range.
      </li><li><i>d</i>: a small deviation to hue and brightness.
      </li><li><i>n</i>: if larger than 1 a color list of n elements is returned.
    </li></ul>

    <p>Last but not least, you can use the + operator to combine two ranges.</p>
    <p> </p>
    <hr/>

    <h2><a id="shade" name="shade" title="shade"></a>Predefined color ranges: shades</h2>

    <p>We’ve already included some predefined color range variables in the library for you. We call
    them <b>shades</b>. These includes useful concepts such as <i>light</i> and <i>dark</i>,
    defined by a combination of saturation and brightness.</p>
    <p>All of the shades are in the <i>shades</i> list:</p>
<pre>print colors.shades
&gt;&gt;&gt; [light, dark, bright, weak, neutral, fresh, soft, hard, warm, 
&gt;&gt;&gt;  cool, intense]
</pre>    

    <ul>
      <li><b>light:</b> bright and light colors.
      </li><li><b>dark:</b> deep and colorfully saturated.
      </li><li><b>bright:</b> colorful and friendly.
      </li><li><b>weak:</b> neither light, soft nor neutral.
      </li><li><b>neutral:</b> desaturated and neither bright nor dark.
      </li><li><b>fresh:</b> light and friendly with a higher saturation than soft shades.
      </li><li><b>soft:</b> gentle pastel colors with small difference in saturation.
      </li><li><b>hard:</b> powerful colors but lighter than intense shades.
      </li><li><b>warm:</b> gently saturated and gently bright.
      </li><li><b>cool:</b> cold, bright and desaturated.
      </li><li><b>intense:</b> powerful deep/bright contrasts.<br/>
    </li></ul>

    <p>Here’s a visual overview of all the shades. The <i>shades</i> list is traversed. Each
    individual shade is then called as a command (remember we can call color ranges like commands)
    and limited to a yellow hue. Since we also call the range with the <i>n</i> parameter, a
    <b>list</b> of range-constrained yellow colors is returned.</p>
<pre>x = 20
y = 20
for shade in colors.shades:
    text(shade.name, x, y-5, fill=0.2, fontsize=12)
    clr = shade(colors.yellow(), n=10)
    clr.swatch(x, y)
    x += 45
</pre>    

    <p><img alt="colors-shades0" height="400" src="../etc/lib/colors-shades0.jpg" width="550"/><br/></p>
    <p>The <i>shade()</i> command returns a shade by name:
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors-shades1" height="100" src="../etc/lib/colors-shades1.jpg" width="100"/></span>
          </td><td>
<pre>
clrs = colors.shade("intense")
clrs = clrs(colors.yellow(), n=20)
clrs.swarm(50,50)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>You can also use shade variables directly. Here’s a dark indigo color:<br/>
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors-shades2" height="100" src="../etc/lib/colors-shades2.jpg" width="100"/></span>
          </td><td>
<pre>
background(colors.dark(colors.indigo()))
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <p>Intense colors of any hue by simply calling the intense range without any parameter:<br/>
    <table>
      <tbody>
        <tr>
          <td><img alt="colors-shades3" height="100" src="../etc/lib/colors-shades3.jpg" width="100"/>
          </td><td>
<pre>
transform(CORNER)
rotate(45)
for i in range(HEIGHT/10):
    fill(colors.intense())
    rect(-WIDTH, i*10, WIDTH*2, 20)
</pre>
          </td></tr></tbody></table></p>
    <p> </p>
    <hr/>

    <p><span class="grey_box">Color shade inference</span></p>
    <p>Now that we have learned about shades it is easy to deduce some information from individual
    colors. First of all, we can check if a colors falls within a certain shade range (check if a
    color is dark or bright for example):</p>
<pre>clr = colors.red()
print clr in colors.bright
&gt;&gt;&gt; True # red is a bright color.
</pre>

    <p>And since we can find out if a color is dark, bright, neutral, cool, etc. we can guess a
    name for it:</p>
<pre>print colors.guess_name( color(1, 0, 0.5) )
&gt;&gt;&gt; bright pink
</pre>    
    <hr/>

    <h2><a id="theme" name="theme" title="theme"></a>Grouping ranges into color themes</h2>

    <p>We can group different <a href="#range">color ranges</a> into a color theme. Each of the
    color ranges in a theme has a hue associated with it and a weight which determines its
    frequency in the theme. Simply put, a <i>sand</i> theme would be made up of combinations like
    <i>50% soft ivory</i>, 25% <i>dark goldenrod</i> and <i>25% warm brown</i>.</p>
<pre>theme(name="", guess=False, length=100)
</pre>

    <p>The theme command returns a <i>ColorTheme</i> object with the following properties:</p>
    <ul>
      <li><i>theme.name</i>: the name of the theme.
      </li><li><i>theme.ranges</i>: a list of (color, range, weight)-tuples.
      </li><li><i>theme.tags</i>: a list of associated keywords.
      </li><li><i>theme.length</i>: the number of colors returned in a for-loop.
    </li></ul>

    <p><br/>
    To add a color range to the theme you use the <i>theme.add_range()</i> method:</p>
<pre>theme.add_range(range, clr=None, weight=1.0)
</pre>

    <p>You can supply <a href="#shade">shades</a>, your own color ranges, or a <i>shade + named
    color</i> string to the <i>range</i> parameter. The following two themes are the same (by ‘the
    same’ we mean that they contain the same ranges - however, their output may vary as ranges do
    not contain fixed colors).
    <table border="0">
      <tbody>
        <tr>
          <td><img alt="colors-range1" height="100" src="../etc/lib/colors-range1.jpg" width="100"/>
          </td><td>
<pre>
sand = colors.theme()
sand.add_range(colors.soft, colors.ivory(), weight=0.5)
sand.add_range(colors.dark, colors.goldenrod(), weight=0.25)
sand.add_range(colors.warm, colors.brown(), weight=0.25)
sand.swatch(2, 2, w=7, h=7, padding=1)
</pre>
        </td></tr><tr>
          <td><img alt="colors-range2" height="100" src="../etc/lib/colors-range2.jpg" width="100"/>
          </td><td>
<pre>
sand = colors.theme()
sand.add_range("soft ivory", weight=0.5)
sand.add_range("dark goldenrod", weight=0.25)
sand.add_range("warm brown", weight=0.25) 
sand.swatch(2, 2, w=7, h=7, padding=1)
</pre>
          </td></tr></tbody></table></p>
    <p>You can retrieve an individual (random) color from the theme with the <i>theme.color()</i>
    method, or a color list with the <i>theme.colors()</i> method. The weight of each range is
    taken into account - heavier ranges will output more colors.</p>
<pre>theme.color(d=0.035)
</pre>
<pre>theme.colors(n=10, d=0.035)
</pre>

    <p>The optional <i>d</i> parameter provides a slight variation in brightness and saturation.</p>
    <p>To retrieve a single color you can also simply call the theme as a command. Or to retrieve
    multiple colors you can treat it as a list containing <i>length</i> colors (the <i>length</i>
    parameter in the <i>theme()</i> command).<br/></p>
<pre>size(550, 275)
background( sand() )
colors.shadow(alpha=0.4, dx=-40, blur=10)
 
for clr in sand:
    fill(clr)
    translate(10)
    scale(0.96)
    skew(10)
    rect(0, -40, 400, 400)
</pre>

    <p><span class="image_border"><img alt="colors-range3" height="275" src="../etc/lib/colors-range3.jpg" width="550"/></span></p>
    <p>A color theme also has the standard <i>copy()</i>, <i>swatch()</i> and <i>swarm()</i>
    methods. The <i>swatch()</i> method has an additional <i>grouped</i> parameter. When set to
    <i>True</i>, provides a more compact layout.</p>
    <p>You can use the + operator to add two themes together or test if a color is part of a theme
    with the <i>in</i> operator.</p>
    <p>Another interesting method is theme.recombine(). You can use it to create a new generation
    from two parent themes using a cut-and-splice techniques. Check the examples included in the
    library.</p>
<pre>theme1.recombine(theme2, d=0.7)
</pre>

    <p> </p>
    <hr/>

    <p><span class="grey_box">Aggregated themes</span><br/></p>
    <p>The Colors library comes bundled with more than four thousand color themes, grouped into
    four categories: emotion, nature, adjectives, and basic english words. These themes have been
    harvested from the web using the technique explained in the <a href="http://nodebox.net/code/index.php/Prism">Prism</a> example. Some of them look great, others
    decent, others bad. But it’s a good source to get inspiration nonetheless.</p>
    <p>To load an aggregated theme, <b>create a theme with a name</b>:
    <table border="0">
      <tbody>
        <tr>
          <td><span class="image_border"><img alt="colors-range4" height="100" src="../etc/lib/colors-range4.jpg" width="100"/></span>
          </td><td>
<pre>
t = colors.theme("sky", guess=True)
background( colors.list(t).darkest)
t.swarm(50, 50)
</pre>
        </td></tr><tr>
          <td><span class="image_border"><img alt="colors-range5" height="100" src="../etc/lib/colors-range5.jpg" width="100"/></span>
          </td><td>
<pre>
t = colors.theme("love", guess=True)
background( colors.list(t).darkest)
t.swarm(50, 50)
</pre>
          </td></tr></tbody></table></p>
    <p>Adjectives and emotions work best. If a word is not found an exception will be raised. When
    the optional <i>guess</i> parameter is <i>True</i>, a theme will be returned for a word that
    closely matches the given name.</p>
    <hr/>

    <h2><a id="web" name="web" title="web"></a>Aggregating colors from the web</h2>

    <p>If you also have the <a href="Web.html">Web library</a> installed, you can expand the
    database of aggregated themes with your own queries. The <i>google()</i> and <i>yahoo()</i>
    commands will query the web and return a color theme based on the top colors and shades that
    appear in the content of web pages (see <a href="http://nodebox.net/code/index.php/Prism">Prism</a>).</p>
<pre>google(query)
</pre>
<pre>yahoo(query, license=None)
</pre>

    <p>The command returns a <a href="#theme">color theme</a>. With the <i>yahoo()</i> command, you
    can specify your own <a href="Web.html#yahoo">Yahoo! license key</a> with the optional
    <i>license</i> parameter. It will take some time to retrieve all the information from the web
    the first time. After that, the search query is stored locally and can be retrieved instantly.</p>
    <p>Another way to get color information (with good results) is by measuring pixels in online
    images. The morguefile() command will scan thumbnails in the <a href="http://morguefile.com">morgueFile</a> archive for colors:</p>
<pre>morguefile(query, n)
</pre>

    <p>The command will return a <a href="#colorlist">color list</a> with <i>n</i> colors.</p>
    <p> </p>
    <hr/>

    <h2><a id="shader" name="shader" title="shader"></a>Using a shader for lighting effects</h2>

    <p>The Colors library has a useful <i>shader()</i> command that <b>simulates a source of
    light</b>. You can control the source of the light, its direction and strength across the
    canvas to determine the colors of onscreen elements.</p>
<pre>shader(x, y, dx, dy, radius=300, angle=0, spread=90)
</pre>

    <p>The x and y is the position of an element on the canvas. The <i>dx</i> and <i>dy</i> is the
    position of the lightsource. Based on the distance between the two a number from 0.0 (no light)
    to 1.0 (full light) is returned, representing how much light the element receives. The
    <i>radius</i> determines the strength of the light (how far it reaches), <i>angle</i>
    determines the direction in which light is shining (<i>None</i> if it shines equally in all
    directions) and <i>spread</i> determines the extent of the beam (wide or narrow).</p>
    <p>In this example a light source is positioned in the lower right corner. The value returned
    from the <i>shader()</i> command is used to modify each oval’s brightness.<br/></p>
    <p><img alt="colors-shader1" height="300" src="../etc/lib/colors-shader1.jpg" width="550"/></p>
<pre>size(550, 300)
background(0.1,0,0.05)
colormode(HSB)
colors.shadow()
for i in range(3000):
    x = random(WIDTH)
    y = random(HEIGHT)
    r = random(10,30)
    d = colors.shader(x, y, 550, 300, angle=150)
    # HSB is brighter and opaque in the centre of the light.
    fill(0.84+d*0.1, 1, 0.2+0.8*d, d)
    oval(x, y, r, r)
</pre>

    <p>We can get different effects by modifying the position, radius and spread of the light:</p>
<pre>d = colors.shader(x, y, 275, 300, radius=200, angle=90, spread=180)
</pre>

    <p><img alt="colors-shader2" height="300" src="../etc/lib/colors-shader2.jpg" width="550"/></p>
    <p> </p>
    <p>When used together with <i>shadow()</i> and <i>gradientpath()</i>, we can now create
    compositions with a realistic sense of <b>depth</b>:</p>
    <p><img alt="colors-shader3" height="370" src="../etc/lib/colors-shader3.jpg" width="550"/></p>
<pre># Deep green gradient background.
size(400, 400)
bg = rect(0, 0, WIDTH, HEIGHT, draw=False)
colors.gradientpath(bg, color(0.15,0.2,0), color(0,0,0))
 
colors.shadow()
for i in range(800):    
    x = random(400)
    y = random(400)    
    # A lightsource positioned at the centre of the canvas.
    d = colors.shader(x, y, 200, 200, angle=None, radius=150)    
    # Oval become smaller when further away from the light.
    # If they become too small, don't draw them.
    r = d*40
    if r &lt; 4: continue
    p = oval(x, y, r*2, r*2, draw=False)    
    # Two colors for an oval gradient fill.
    # The green becomes lighter and more opaque
    # when elements are nearer to the light.
    nostroke()
    clr1 = color(0.4+d*0.5, 0.6+d*0.3, 0, 0.75)
    clr2 = color(0, 0, 0, d)
    colors.gradientpath(p, clr1, clr2, alpha=0.5+d, dx=r, dy=r)
</pre>

    <p>Let’s just add a few more bells to the script! For each oval at the edge of the nucleus,
    we’ll draw some curves bending inward.</p>
<pre>#   add to the script above:
    nofill()
    stroke(clr1)
    strokewidth(0.25)
    autoclosepath(False)
    if d &lt; 0.3:
        for j in range(random(10)):
            v = (1-d) * 150
            beginpath(x, y)
            curveto(x, y, x+random(-v,v), y+random(-v,v), 200, 200)
            endpath()
</pre>

    <p>With the <a href="Supershape.html">Supershape</a> library we can draw all sorts of organic
    forms. Let’s use it to add a pattern to each oval.</p>
<pre>#   add to the script above:
    supershape = ximport("supershape")
    strokewidth(d*0.75)
    if d &gt; 0.25:
        p = supershape.path(x+r, y+r, r, r, 10, 1.5, -0.5, 1.5)
        drawpath(p)
</pre>

    <p><img alt="colors-shader5" height="550" src="../etc/lib/colors-shader5.jpg" width="550"/><br/></p>
    <p> </p>
    <hr/>

    <h2><a id="shadow" name="shadow" title="shadow"></a>Using dropshadows and gradient fills</h2>

    <p>The Colors library has a <i>shadow()</i> command and a <i>gradientfill()</i> to add depth to
    your compositions. Shadows influence all the elements on the canvas while gradients are applied
    to a given <a href="../ref/Drawing.html#BezierPath">path</a>.</p>
<pre>shadow(dx=10, dy=10, alpha=0.25, blur=4.0)
</pre>
<pre>noshadow()
</pre>
<pre>gradientfill(path, clr1, clr2, type="radial", 
             dx=0, dy=0, spread=1.0, angle=0, alpha=1.0)
</pre>

    <p>The <i>shadow()</i> and <i>noshadow()</i> commands work like <a href="../ref/Line+Color.html#fill()">fill()</a> and <a href="../ref/Line+Color.html#nofill()">nofill()</a>. Once you set a shadow all the subsequent
    elements you draw to the canvas will have a dropshadow (or until <i>nofill()</i> is called).
    The <i>dx</i> and <i>dy</i> define the shadow’s offset, <i>alpha</i> the shadow’s opacity and
    <i>blur</i> its sharpness.</p>
    <p>The <i>gradientfill()</i> command takes a given <i>path</i> just like <a href="../ref/Drawing.html#drawpath()">drawpath()</a> and draws it to the screen filled with a
    gradient ranging between <a href="../ref/Line+Color.html#color()">colors</a> <i>clr1</i> and
    <i>clr2</i>. The <i>type</i> of gradient can be ‘radial’ or ‘linear’.</p>
    <p>The <i>spread</i> parameter is the distance between the two colors. It can be a relative
    float number between 0.0 and 1.0 or an absolute int. In the case of a float, 1.0 represents the
    highest of either width and height for radial gradients, and the lowest of width and height for
    linear gradients.</p>
    <p>It’s also useful to note the <i>alpha</i> parameter. When a gradient fill is drawn, the path
    is first filled with an opaque color, and the gradient mask is then drawn on top of that. While
    <i>clr1</i> and <i>clr2</i> can have their individual alpha value, <i>alpha</i> controls the
    opacity of the opaque underground. When you hide the opaque underground, no shadows will be
    rendered for this layer - so it’s bit of tweaking to combine shadows and gradients.<br/></p>
    <p>An example with shadows and gradient supershapes:<br/></p>
<pre># Enable dropshadows
colors.shadow(alpha=0.75)
rotate(90)
for i in range(100):
    # Combination of rotate, scale and translate yields a spiral.
    rotate(14)
    scale(0.95)
    translate(50, 0)
    # A pointy supershape path.
    supershape = ximport("supershape")
    path = supershape.path(650, 500, 350, 350, 6, 0.74, 0.3, -4.64-i)
    # The gradient fill.
    # Notice how the second color alters in each iteration.
    colors.gradientfill(
        path, 
        color(0.0, 0.6, 0.9, 0.25), 
        color(0.18+i*0.03, 0.0, 0.1+i*0.01, 0.9-i*0.02), 
        dx=88-i*10, dy=-25+i, 
        spread=0.83, 
        alpha=0.25
    )
</pre>

    <p><img alt="colors-gradient1" height="519" src="../etc/lib/colors-gradient1.jpg" width="550"/><br/></p>
  </div>

</body></html>